{"meta":{"title":"木槿少年的博客","subtitle":"每一个不曾起舞的日子都是对生命的辜负","description":"前端学习","author":"winnie","url":"https://www.cuicui88.com","root":"/"},"pages":[],"posts":[{"title":"leetcode-300-301-312","slug":"leetcode-300-301-312","date":"2019-10-31T02:58:48.000Z","updated":"2019-10-31T03:18:22.395Z","comments":true,"path":"2019/10/31/leetcode-300-301-312/","link":"","permalink":"https://www.cuicui88.com/2019/10/31/leetcode-300-301-312/","excerpt":"leetcode 300题301题302题","text":"leetcode 300题301题302题 leetcode300题题目（最长上升子序列）：给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例：输入：[10,9,2,5,3,7,101,18] 输出：4 解释：最长的上升子序列是 [2,3,7,101]，它的长度是 4。 解答：12345678910111213141516var lengthOfLIS = function(nums) &#123; var dp = []; for(var h=0;h&lt;nums.length;h++)&#123; dp[h] = 1; &#125; var result = 0; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=0;j&lt;i;j++)&#123; if(nums[i]&gt;nums[j])&#123; dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; result = Math.max(dp[i],result); &#125; return result;&#125;; leetcode301题题目（删除无效的括号）：删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例：输入：”()())()” 输出：[“()()()”, “(())()”] 输入：”(a)())()” 输出：[“(a)()()”, “(a())()”] 输入：”)(“ 输出：[“”] 解答（深度优先遍历）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var removeInvalidParentheses = function(s) &#123; var result = []; return removeInvalidParentheses1(s); function removeInvalidParentheses1(s)&#123; var left = 0; var right = 0; for(var h=0;h&lt;s.length;h++)&#123;//判断其中应该消掉的左右括号数目 var char = s[h]; if(char==&apos;(&apos;)&#123; left++; &#125; if(char==&apos;)&apos;)&#123; if(left&gt;0)&#123; left--; &#125;else&#123; right++; &#125; &#125; &#125; dfs(s,0,left,right); return result; &#125; function dfs(s,start,left,right)&#123;//深度优先遍历进行括号消除 if(left==0&amp;&amp;right==0)&#123; if(check(s))&#123; result.push(s); &#125; return; &#125; for(var i=start;i&lt;s.length;i++)&#123; if(i-1&gt;=start&amp;&amp;s[i]==s[i-1])&#123; continue; &#125; if(left&gt;0&amp;&amp;s[i]==&apos;(&apos;)&#123; dfs(s.substr(0,i)+s.substr(i+1,s.length-i-1),i,left-1,right); &#125; if(right&gt;0&amp;&amp;s[i]==&apos;)&apos;)&#123; dfs(s.substr(0,i)+s.substr(i+1,s.length-i-1),i,left,right-1); &#125; &#125; &#125; function check(s)&#123;//检查是否满足正常括号对 var count = 0; for(var h=0;h&lt;s.length;h++)&#123; var char = s[h]; if(char==&apos;(&apos;)&#123; count++; &#125; if(char==&apos;)&apos;)&#123; count--; if(count&lt;0)&#123; return false; &#125; &#125; &#125; return count==0; &#125;&#125;; leetcode312题题目（戳气球）：有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] nums[i] nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例： 解答：123456789101112131415161718192021var maxCoins = function(nums) &#123; nums.unshift(1); nums.push(1); var length = nums.length; var dp = []; for(var i=0;i&lt;length;i++)&#123; dp[i] = []; for(var j=0;j&lt;length;j++)&#123; dp[i][j] = 0; &#125; &#125; for(var len=2;len&lt;=length;len++)&#123; for(var i=0;i&lt;=length-len;i++)&#123; var j = i+len-1; for(var k=i+1;k&lt;j;k++)&#123; dp[i][j] = Math.max(dp[i][j],nums[i]*nums[k]*nums[j]+dp[i][k]+dp[k][j]); &#125; &#125; &#125; return dp[0][length-1];&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"share-leetcode-121-122-309-714-123-188","slug":"share-leetcode-121-122-309-714-123-188","date":"2019-10-30T02:35:10.000Z","updated":"2019-10-30T03:47:35.023Z","comments":true,"path":"2019/10/30/share-leetcode-121-122-309-714-123-188/","link":"","permalink":"https://www.cuicui88.com/2019/10/30/share-leetcode-121-122-309-714-123-188/","excerpt":"leetcode股票题目121题122题309题714题123题188题","text":"leetcode股票题目121题122题309题714题123题188题 题目列表（题目从易到难）：121. 买卖股票的最佳时机122. 买卖股票的最佳时机 II309. 最佳买卖股票时机含冷冻期714. 买卖股票的最佳时机含手续费123. 买卖股票的最佳时机 III188. 买卖股票的最佳时机 IV解析：&nbsp;&nbsp;&nbsp;&nbsp;这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 &nbsp;&nbsp;&nbsp;&nbsp;第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 1.穷举：&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。 &nbsp;&nbsp;&nbsp;&nbsp;每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。 &nbsp;&nbsp;&nbsp;&nbsp;很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： 123456789dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for 0 &lt;= i &lt; n: for 1 &lt;= k &lt;= K: for s in &#123;0, 1&#125;: dp[i][k][s] = max(buy, sell, rest) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们想求的最终答案是 dp[n-1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。 2.状态转移框架：&nbsp;&nbsp;&nbsp;&nbsp;现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 &nbsp;&nbsp;&nbsp;&nbsp;通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： 12345678910111213dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell )解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy )解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 &nbsp;&nbsp;&nbsp;&nbsp;这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 &nbsp;&nbsp;&nbsp;&nbsp;现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 12345678dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 把上面的状态转移方程总结一下： 1234567base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 具体题目：leetcode121题（k=1）：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例： 题解：直接套状态转移方程，根据 base case，可以做一些化简： 12345678910111213dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i])发现dp[i][0]由前一步的dp[i][0]与dp[i][1]决定（即由dp[i-1][0]与dp[i-1][1]决定），因此可以取消数组的写法：dp_i_0 = max(dp_i_0,dp_i_1+prices[i]);dp_i_1 = max(dp_i_1,-prices[i]); 综上，代码为： 123456789var maxProfit = function(prices) &#123; var dp_i_0 = 0;//相当于设置dp[-1][0]时的值 var dp_i_1 = -Infinity;//相当于设置dp[-1][1]时的值 for(var i=0;i&lt;prices.length;i++)&#123; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,-prices[i]); &#125; return dp_i_0;&#125;; leetcode122题（k=+Infinity）：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例： 题解：123456789dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 发现k是无穷，因此k和k-1是一样大小的。发现dp[i][0]由前一步的dp[i][0]与dp[i][1]决定（即由dp[i-1][0]与dp[i-1][1]决定），因此可以取消数组的写法：var temp = dp_i_0;dp_i_0 = max(dp_i_0,dp_i_1+prices[i]);dp_i_1 = max(dp_i_1,temp-prices[i]); 代码如下：12345678910var maxProfit = function(prices) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,temp-prices[i]); &#125; return dp_i_0;&#125;; leetcode309题（k=+Infinity含冷冻期）：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例： 题解：每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： 123dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。 具体代码： 123456789101112var maxProfit = function(prices) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; var dp_prev = 0; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,dp_prev-prices[i]); dp_prev = temp; &#125; return dp_i_0;&#125;; leetcode714题（k=+Infinity 含手续费）：给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 示例： 题解：每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： 1234dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)解释：相当于买入股票的价格升高了。在第一个式子里减也是一样的，相当于卖出股票的价格减小了。 代码实现：12345678910var maxProfit = function(prices, fee) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]-fee); dp_i_1 = Math.max(dp_i_1,temp-prices[i]); &#125; return dp_i_0;&#125;; leetcode123题（k=2）：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例： 题解：k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。 123456789原始的动态转移方程，没有可化简的地方dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) 代码实现：12345678910111213var maxProfit = function(prices) &#123; var dp_i_20 = 0; var dp_i_10 = 0; var dp_i_21 = -Infinity; var dp_i_11 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; dp_i_20 = Math.max(dp_i_20,dp_i_21+prices[i]); dp_i_21 = Math.max(dp_i_21,dp_i_10-prices[i]); dp_i_10 = Math.max(dp_i_10,dp_i_11+prices[i]); dp_i_11 = Math.max(dp_i_11,-prices[i]); &#125; return dp_i_20;&#125;; leetcode188题（k=k）：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例： 题解：有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 代码实现：12345678910111213141516171819202122232425262728var maxProfit = function(k, prices) &#123; if(k&gt;parseInt(prices.length/2))&#123; return maxProfitAnyk(prices); &#125; var dp = []; for(var j=0;j&lt;k+1;j++)&#123; dp[j] = []; dp[j][0]=0; dp[j][1]=-Infinity; &#125; for(var i=0;i&lt;prices.length;i++)&#123; for(var j=k;j&gt;=1;j--)&#123; dp[j][0] = Math.max(dp[j][0],dp[j][1]+prices[i]); dp[j][1] = Math.max(dp[j][1],dp[j-1][0]-prices[i]); &#125; &#125; return dp[k][0];&#125;;var maxProfitAnyk = function(prices) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,temp-prices[i]); &#125; return dp_i_0;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-322-337-338","slug":"leetcode-322-337-338","date":"2019-10-28T11:43:03.000Z","updated":"2019-10-28T11:54:14.444Z","comments":true,"path":"2019/10/28/leetcode-322-337-338/","link":"","permalink":"https://www.cuicui88.com/2019/10/28/leetcode-322-337-338/","excerpt":"leetcode 322题 337题 338题","text":"leetcode 322题 337题 338题 leetcode332题：零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例：输入：coins = [1,2,5],amount = 11 输出：3 解释：11 = 5+5+1 输入：coins = [2], amount = 3 输出：-1 解答：123456789101112131415161718192021var coinChange = function(coins, amount) &#123; if(coins.length==0)&#123; return -1; &#125; var dp = []; for(var i=1;i&lt;=amount;i++)&#123; dp[i] = Infinity; &#125; dp[0] = 0; for(var i=0;i&lt;coins.length;i++)&#123; for(var j=coins[i];j&lt;=amount;j++)&#123; if(dp[j-coins[i]]!=Infinity)&#123; dp[j] = Math.min(dp[j],dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=Infinity)&#123; return dp[amount]; &#125; return -1;&#125;; leetcode337题：打家劫舍III在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例： 解答：12345678910111213var rob = function(root) &#123; if(root==null)&#123; return 0; &#125; var val = 0; if(root.left!=null)&#123; val = val + rob(root.left.left)+rob(root.left.right); &#125; if(root.right!=null)&#123; val = val + rob(root.right.left)+rob(root.right.right); &#125; return Math.max(root.val+val,rob(root.left)+rob(root.right));&#125;; leetcode338题：比特位计数给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例：输入：2 输出：[0,1,1] 输入：5 输出：[0,1,1,2,1,2] 进阶： 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 解答：12345678910111213141516171819202122232425//非进阶版var countBits = function(num) &#123; var result = []; for(var i=0;i&lt;=num;i++)&#123; var bits = i.toString(2); var count = 0; for(var j=0;j&lt;bits.length;j++)&#123; if(bits[j]==&apos;1&apos;)&#123; count++; &#125; &#125; result.push(count); &#125; return result;&#125;;//进阶版/*i &amp; (i - 1)可以去掉i最右边的一个1（如果有），因此 i &amp; (i - 1）是比 i 小的，而且i &amp; (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i &amp; (i - 1)的1的个数加上1.*/var countBits = function(num) &#123; var result = []; result[0] = 0; for(var i=1;i&lt;=num;i++)&#123; result[i] = result[i&amp;(i-1)]+1;//&amp;表示按位与 &#125; return result;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-347-394","slug":"leetcode-347-394","date":"2019-10-25T07:41:57.000Z","updated":"2019-10-25T07:50:23.380Z","comments":true,"path":"2019/10/25/leetcode-347-394/","link":"","permalink":"https://www.cuicui88.com/2019/10/25/leetcode-347-394/","excerpt":"leetcode347题394题","text":"leetcode347题394题 leetcode347题题目：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例：示例1： 输入：nums = [1,1,1,2,2,3], k = 2 输出：[1,2] 示例2： 输入：nums = [1], k = 1 输出：[1] 解答：12345678910111213141516171819202122232425262728var topKFrequent = function(nums, k) &#123; function Node(n,c)&#123; this.num = n; this.count = c; &#125; var obj = &#123;&#125;; for(var i=0;i&lt;nums.length;i++)&#123; if(obj[nums[i]]==undefined)&#123; obj[nums[i]]=new Node(nums[i],1); &#125;else&#123; obj[nums[i]].count++; &#125; &#125; var arr = []; for(var prop in obj)&#123; arr.push(obj[prop]); &#125; arr.sort(compare); var result = []; for(var i=0;i&lt;k;i++)&#123; var index = arr.length-1-i; result.push(arr[index].num); &#125; return result;&#125;;function compare(a,b)&#123; return a.count-b.count;&#125; leetcode394题题目：给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例：s = “3[a]2[bc]”, 返回 “aaabcbc”.s = “3[a2[c]]”, 返回 “accaccacc”.s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”. 解答：1234567891011121314151617181920212223var decodeString = function(s) &#123; while(s.indexOf(&apos;]&apos;)!=-1)&#123; var indexEnd = s.indexOf(&apos;]&apos;); var indexStart = indexEnd; while(s[indexStart]!=&apos;[&apos;)&#123; indexStart--; &#125; var nums = []; var index = indexStart; while(!isNaN(parseInt(s[index-1]))&amp;&amp;index!=0)&#123; nums.push(s[index-1]); index--; &#125; var num = parseInt(nums.reverse().join(&apos;&apos;)); var result = &apos;&apos;; for(var i=0;i&lt;num;i++)&#123; var str = s.substring(indexStart+1,indexEnd); result = result+str; &#125; s = s.substring(0,index)+result+s.substring(indexEnd+1,s.length); &#125; return s;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-406-416","slug":"leetcode-406-416","date":"2019-10-25T01:12:11.000Z","updated":"2019-10-25T01:23:16.851Z","comments":true,"path":"2019/10/25/leetcode-406-416/","link":"","permalink":"https://www.cuicui88.com/2019/10/25/leetcode-406-416/","excerpt":"leetcode 406题 416题","text":"leetcode 406题 416题 leetcode406题题目：假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 示例：输入：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出：[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解答：12345678910111213141516var reconstructQueue = function(people) &#123; var result = []; people.sort(compare); for(var i=0;i&lt;people.length;i++)&#123; var index = people[i][1]; result.splice(index,0,people[i]); &#125; return result;&#125;;function compare(a,b)&#123; if(a[0]==b[0])&#123; return a[1]-b[1]; &#125; return b[0]-a[0];&#125; leetcode416题题目：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100；数组的大小不会超过 200。 示例：示例1： 输入：[1, 5, 11, 5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11]. 示例2： 输入：[1, 2, 3, 5] 输出：false 解释：数组不能分割成两个元素和相等的子集. 解答：123456789101112131415161718192021var canPartition = function(nums) &#123; var sum = 0; for(var h=0;h&lt;nums.length;h++)&#123; sum = sum + nums[h]; &#125; if(sum%2!=0)&#123; return false; &#125; var halfSum = parseInt(sum/2); var arr = []; for(var j=0;j&lt;halfSum+1;j++)&#123; arr[j] = false; &#125; arr[0] = true; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=halfSum;j&gt;=nums[i];j--)&#123; arr[j] = (arr[j]||arr[j-nums[i]])?true:false; &#125; &#125; return arr[halfSum];&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-112-113-437","slug":"leetcode-112-113-437","date":"2019-10-22T14:18:27.000Z","updated":"2019-10-22T15:26:09.851Z","comments":true,"path":"2019/10/22/leetcode-112-113-437/","link":"","permalink":"https://www.cuicui88.com/2019/10/22/leetcode-112-113-437/","excerpt":"leetcode 112题 113题 437题","text":"leetcode 112题 113题 437题 leetcode 112题题目：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 解答：123456789var hasPathSum = function(root, sum) &#123; if(root==null)&#123; return false; &#125; if(root.left==null&amp;&amp;root.right==null)&#123; return sum-root.val==0; &#125; return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);&#125;; leetcode113题题目：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 解答：123456789101112131415161718192021222324var pathSum = function(root, sum) &#123; var result = []; get(root,0,[],result); function get(node,currentSum,currentList,result)&#123; if(node==null)&#123; return; &#125; currentSum = currentSum + node.val; currentList.push(node.val); if(node.left==null&amp;&amp;node.right==null)&#123; if(currentSum==sum)&#123; result.push(JSON.parse(JSON.stringify(currentList))); //console.log(result); &#125; currentList.pop(); return; &#125; get(node.left,currentSum,currentList,result); get(node.right,currentSum,currentList,result); currentList.pop(); &#125; return result;&#125;; leetcode437题题目：给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 解答：123456789101112131415161718192021222324var pathSum = function(root, sum) &#123; var count = 0; function pathSum1(root,sum)&#123; if(root==null)&#123; return 0; &#125; Sum(root,sum); pathSum1(root.left,sum); pathSum1(root.right,sum); &#125; function Sum(root,sum)&#123; if(root==null)&#123; return; &#125; sum = sum - root.val; if(sum==0)&#123; count++; &#125; Sum(root.left,sum); Sum(root.right,sum); &#125; pathSum1(root,sum); return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-448-461","slug":"leetcode-448-461","date":"2019-10-21T12:05:47.000Z","updated":"2019-10-21T12:20:20.768Z","comments":true,"path":"2019/10/21/leetcode-448-461/","link":"","permalink":"https://www.cuicui88.com/2019/10/21/leetcode-448-461/","excerpt":"leetcode 448题 461题","text":"leetcode 448题 461题 leetcode 448题题目：给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例：输入：[4,3,2,7,8,2,3,1] 输出：[5,6] 解答：思路：第一个for循环相当于是将输入数组中，与数组中元素值-1对应位置的数加上数组长度，那么循环结束之后，如果某个位置上的元素值是大于数组长度的，那么代表这个位置上有相应的元素出现，如果是小于或等于的，那么代表没有相应的元素出现。那么返回这个位置值+1。 12345678910111213var findDisappearedNumbers = function(nums) &#123; for(var i=0;i&lt;nums.length;i++)&#123; var index = (nums[i]-1)%nums.length; nums[index] = nums[index] + nums.length; &#125; var res = []; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&lt;=nums.length)&#123; res.push(i+1); &#125; &#125; return res;&#125;; leetcode 461题题目：两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 解答：123456789101112131415161718192021222324252627//这种方法空间复杂度太高var hammingDistance = function(x, y) &#123; var str1 = x.toString(2); var str2 = y.toString(2); var arr1 = str1.split(&apos;&apos;); var arr2 = str2.split(&apos;&apos;); var len = Math.max(arr1.length,arr2.length); var dis; if(len&gt;arr1.length)&#123; dis = len - arr1.length; while(dis--)&#123; arr1.unshift(0); &#125; &#125;else&#123; dis = len - arr2.length; while(dis--)&#123; arr2.unshift(0); &#125; &#125; var count = 0; for(var i=0;i&lt;arr1.length;i++)&#123; if(arr1[i]!=arr2[i])&#123; count++; &#125; &#125; return count;&#125;; 123456789101112//空间复杂度低的方法var hammingDistance = function(x, y) &#123; x = x^y;//x与y的异或 var count = 0; while(x!=0)&#123; if(x%2==1)&#123; count++; &#125; x&gt;&gt;=1; &#125; return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-494-538","slug":"leetcode-494-538","date":"2019-10-21T03:49:17.000Z","updated":"2019-10-21T04:03:35.301Z","comments":true,"path":"2019/10/21/leetcode-494-538/","link":"","permalink":"https://www.cuicui88.com/2019/10/21/leetcode-494-538/","excerpt":"leetcode 494 538题","text":"leetcode 494 538题 leetcode 494题题目：给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 解答：123456789101112131415161718192021var findTargetSumWays = function(nums, S) &#123; var sum = 0; for(var i=0;i&lt;nums.length;i++)&#123; sum = sum + nums[i]; &#125; if(sum&lt;S||(sum+S)%2!=0)&#123; return 0; &#125; var arr = []; var w = parseInt((sum+S)/2); for(var j=0;j&lt;w+1;j++)&#123; arr[j] = 0; &#125; arr[0] = 1; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=w;j&gt;=nums[i];j--)&#123; arr[j] = arr[j] + arr[j-nums[i]]; &#125; &#125; return arr[w];&#125;; leetcode538题题目：给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 解答：1234567891011121314var convertBST = function(root) &#123; var num = 0; function convert1(root)&#123; if(root==null)&#123; return; &#125; convert1(root.right); root.val = root.val + num; num = root.val; convert1(root.left); &#125; convert1(root); return root;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-543-560","slug":"leetcode-543-560","date":"2019-10-18T07:33:22.000Z","updated":"2019-10-18T07:45:27.532Z","comments":true,"path":"2019/10/18/leetcode-543-560/","link":"","permalink":"https://www.cuicui88.com/2019/10/18/leetcode-543-560/","excerpt":"leetcode 543 560题","text":"leetcode 543 560题 leetcode543题题目：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 解答：123456789101112131415var diameterOfBinaryTree = function(root) &#123; var result = 0; deep(root); return result; function deep(root)&#123; if(!root)&#123; return -1; &#125; var left = root.left?deep(root.left)+1:0; var right = root.right?deep(root.right)+1:0; result = Math.max(left+right,result); return Math.max(left,right); &#125;&#125;; leetcode 560题题目：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例：&nbsp;&nbsp;&nbsp;&nbsp;输入：nums = [1,1,1],k=2 &nbsp;&nbsp;&nbsp;&nbsp;输出：2, [1,1]与[1,1]为两种不同的情况。 解答：12345678910111213var subarraySum = function(nums, k) &#123; var count = 0; for(var i=0;i&lt;nums.length;i++)&#123; var sum = 0; for(var j=i;j&lt;nums.length;j++)&#123; sum += nums[j]; if(sum==k)&#123; count++; &#125; &#125; &#125; return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-572-581","slug":"leetcode-572-581","date":"2019-10-16T13:38:51.000Z","updated":"2019-10-16T14:09:44.320Z","comments":true,"path":"2019/10/16/leetcode-572-581/","link":"","permalink":"https://www.cuicui88.com/2019/10/16/leetcode-572-581/","excerpt":"leetcode 572 581题","text":"leetcode 572 581题 leetcode572题题目：给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 解答： 先定义一个函数isCommon，这个函数用来判断两个树是否是相等的。 然后在isSubtree这个函数中，首先判断s是否为null，如果为null，返回false；如果s和t经isCommon这个函数判断是相同的，那么返回true；否则去判断，s.left里面是否包含树t或者s.right里面是否包含树t。 123456789101112131415161718192021var isSubtree = function(s, t) &#123; if(!s)&#123; return false; &#125; if(isCommon(s,t))&#123; return true; &#125; return isSubtree(s.left,t)||isSubtree(s.right,t);&#125;;function isCommon(s,t)&#123; if(!s&amp;&amp;!t)&#123; return true; &#125; if(!s||!t)&#123; return false; &#125; if(s.val!==t.val)&#123; return false; &#125; return isCommon(s.left,t.left)&amp;&amp;isCommon(s.right,t.right);&#125; leetcode581题题目：给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例：&nbsp;&nbsp;&nbsp;&nbsp;输入: [2, 6, 4, 8, 10, 9, 15]&nbsp;&nbsp;&nbsp;&nbsp;输出: 5&nbsp;&nbsp;&nbsp;&nbsp;解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 解答：分为两个步骤： 遍历整个数组元素，确定最终的high值。如果是数组的第一个元素，那么将maxValue值确定为该值，如果不是，将nums[i]值与maxValue值进行比较，如果小于maxValue，代表这个值是乱序中的一个，故此时的high值为这个元素对应的i；无论是否小于maxValue，我们都需要重新确定maxValue值，这个值为现在的maxValue值与nums[i]两者最大值。 同上面，遍历整个数组元素，确定最终的low值。如果是数组的最后一个元素，将minValue确定为该值，如果不是，将nums[i]与minValue值进行比较，如果大于minValue，代表这个值是乱序中的一个，故此时的low值为这个元素对应的i；无论是否大于minValue，我们都需要重新确定maxValue值，这个值为现在的minValue值与nums[i]两者的最小值。 确定了low和high，就可以通过两者的差值再加1得到最终的乱序序列长度。 123456789101112131415161718192021222324252627282930var findUnsortedSubarray = function(nums) &#123; if(nums.length==0||nums.length==1)&#123; return 0; &#125; var maxValue; var minValue; var high = 0; var low = 1; for(var i=0;i&lt;nums.length;i++)&#123; if(i==0)&#123; maxValue = nums[i]; &#125;else&#123; if(nums[i]&lt;maxValue)&#123; high = i; &#125; maxValue = Math.max(nums[i],maxValue); &#125; &#125; for(var i=nums.length-1;i&gt;=0;i--)&#123; if(i==nums.length-1)&#123; minValue = nums[i]; &#125;else&#123; if(nums[i]&gt;minValue)&#123; low = i; &#125; minValue = Math.min(nums[i],minValue); &#125; &#125; return high-low+1;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-617-621","slug":"leetcode-617-621","date":"2019-10-15T13:51:56.000Z","updated":"2019-10-15T14:08:28.576Z","comments":true,"path":"2019/10/15/leetcode-617-621/","link":"","permalink":"https://www.cuicui88.com/2019/10/15/leetcode-617-621/","excerpt":"leetcode 617题 621题","text":"leetcode 617题 621题 leetcode617题题目给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 解答：123456789101112var mergeTrees = function(t1, t2) &#123; if(t1==null)&#123; return t2; &#125; if(t2==null)&#123; return t1; &#125; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); return t1;&#125;; leetcode621题题目：给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例:&nbsp;&nbsp;&nbsp;&nbsp;输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2&nbsp;&nbsp;&nbsp;&nbsp;输出: 8&nbsp;&nbsp;&nbsp;&nbsp;执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 解答：123456789101112131415161718192021222324var leastInterval = function(tasks, n) &#123; var obj = &#123;&#125;; for(var i=0;i&lt;tasks.length;i++)&#123; if(obj[tasks[i]]!=undefined)&#123; obj[tasks[i]]++; &#125;else&#123; obj[tasks[i]]=1; &#125; &#125; var maxValue = 0; var count=0; for(var key in obj)&#123; if(maxValue&lt;obj[key])&#123; maxValue = obj[key]; &#125; &#125; for(var key in obj)&#123; if(maxValue==obj[key])&#123; count++; &#125; &#125; return Math.max.call(null,tasks.length,(maxValue-1)*(n+1)+count);&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode 647 771","slug":"leetcode-647-771","date":"2019-10-14T13:26:01.000Z","updated":"2019-10-15T14:12:43.227Z","comments":true,"path":"2019/10/14/leetcode-647-771/","link":"","permalink":"https://www.cuicui88.com/2019/10/14/leetcode-647-771/","excerpt":"leetcode 647题 771题","text":"leetcode 647题 771题 leetcode 647题 题目：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例1： &emsp;&emsp;输入: “abc” &emsp;&emsp;输出: 3 &emsp;&emsp;解释: 三个回文子串: “a”, “b”, “c”. 示例2： &emsp;&emsp;输入: “aaa” &emsp;&emsp;输出: 6 &emsp;&emsp;说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 解答1（复杂度高的版本）：1234567891011121314151617181920212223242526var countSubstrings = function(s) &#123; var count = s.length; for(var len=2;len&lt;=s.length;len++)&#123; for(var i=0;i&lt;=s.length-len;i++)&#123; var subStr = s.substr(i,len); if(judge(subStr))&#123; count++; &#125; &#125; &#125; return count;&#125;;//首先判断一个字符串是否为回文子串function judge(s)&#123; var s = s.split(&apos;&apos;); if(s.length==1)&#123; return true; &#125; for(var i=0;i&lt;parseInt(s.length/2);i++)&#123; if(s[i]!=s[s.length-1-i])&#123; return false; &#125; &#125; return true;&#125; 解答2（复杂度低的版本）：1234567891011121314151617var countSubstrings = function(s) &#123; var count = 0; for(var i=0;i&lt;=s.length;i++)&#123; count += countSinglePoint(s,i,i);//计算子串长度为奇数对应的回文子串个数 count += countSinglePoint(s,i,i+1);//计算子串长度为偶数对应的回文子串个数 &#125; return count;&#125;;function countSinglePoint(s,i,j)&#123; var num = 0; while(i&gt;=0&amp;&amp;j&lt;s.length&amp;&amp;s[i]==s[j])&#123; i--; j++; num++; &#125; return num;&#125; leetcode771题题目：给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例1： &emsp;&emsp;输入: J = “aA”, S = “aAAbbbb” &emsp;&emsp;输出: 3 示例2： &emsp;&emsp;输入：J = “z”, S = “ZZ” &emsp;&emsp;输出：0 解答1：1234567891011121314var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); var count = 0; for(var i=0;i&lt;str2.length;i++)&#123; for(var j=0;j&lt;str1.length;j++)&#123; if(str2[i]==str1[j])&#123; count++; break; &#125; &#125; &#125; return count;&#125;; 解答2：123456789101112131415var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); var obj = &#123;&#125;; var count = 0; for(var i=0;i&lt;str1.length;i++)&#123; obj[str1[i]] = 1; &#125; for(var j=0;j&lt;str2.length;j++)&#123; if(obj[str2[j]]==1)&#123; count++; &#125; &#125; return count;&#125; 解答3：12345var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); return str2.filter(item=&gt;str1.includes(item)).length;&#125;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"实习面试-微众银行","slug":"micro-public-bank-interview","date":"2019-04-17T09:17:16.000Z","updated":"2019-04-17T09:32:09.365Z","comments":true,"path":"2019/04/17/micro-public-bank-interview/","link":"","permalink":"https://www.cuicui88.com/2019/04/17/micro-public-bank-interview/","excerpt":"微众银行面试凉经","text":"微众银行面试凉经 微众银行面试凉凉： 面试官首先说我的简历太过于简陋（我记得自己是上传了的，感觉很神奇。事后我打开官网看了一下，啥都没有，我也是很迷茫。。） 然后问我有没有做过什么项目，接触过前端的框架没有，我说接触过react，然后用react去模仿了简书的网页。面试官问我项目有没有上线呀什么的，我说没有，只是拿来练手的。然后面试官问我项目中有没有涉及到关于逻辑业务的部分，比如登录注册页面的实现什么的，我说没（还说了通过访问json从后台获取数据这算不算）。估计对项目这里确实是绝望透顶了吧，所以说下面开始问基础知识。————-目测这里就凉了一大截了！！！ 问我平时看什么书，我说我看的是红宝书-javascript高级程序设计，然后就让我解释一下原型链，我解释了一下。然后面试官说我基础还不错。 中途因为我的电脑网速太慢，切到了手机上面试（面试官说他本来要让编程的，编程的话，主要好像是要做链表和字符串的编程，现在想想，我还是手写代码写的太少了，然后算法的准备也不充足–》面试之前只准备了快速排序，冒泡排序还有深度遍历和广度遍历）。然后问了我赛马问题，我当时一脸懵，对于完全没有看过这个题的我感觉很难，然后一切就这样结束了。 又是不到20分钟的一场面试，综合来看，这段时间基础复习得还算可以了。但是项目方面，真的是一言难尽。前后端的这些交互啊什么的，是必须要的（突然想起来师兄说：他到公司就会做项目。现在才意识到自己这方面的不足）。然后就是算法题方面，虽然因为电脑网速的原因没有敲代码（虽然我感觉就算我敲也敲不出来哈哈哈），但是肯定欠缺很大。智力题的话，我实在是没辙啊！！ 综上，现在要准备的是算法题和项目，算法题的话，每天两道前端的算法题，滚瓜烂熟。然后项目的话，要去实现一些复杂的功能，不然面试官会很无语的，面啥挂啥！！","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.cuicui88.com/tags/面试/"}]},{"title":"mood-2019-3-27","slug":"mood-2019-3-27","date":"2019-03-27T04:05:07.000Z","updated":"2019-03-27T05:58:10.764Z","comments":true,"path":"2019/03/27/mood-2019-3-27/","link":"","permalink":"https://www.cuicui88.com/2019/03/27/mood-2019-3-27/","excerpt":"今天任务完成的不太好","text":"今天任务完成的不太好 &emsp;今天老师叫我们去提交任务完成情况的时候，我匆匆忙忙，并没有将老师需要我们提交的内容整理出来。因为几乎忘记了老师之前要求我做的事情。包括写方案分析和报告以及关于搜索唤醒词识别的相关内容（我做的事情是继续老师上一次布置的任务）。 &emsp;事实证明，先弄完老师东西，再去做自己的事情，才是比较正确的，不然会心力交瘁！","categories":[{"name":"life","slug":"life","permalink":"https://www.cuicui88.com/categories/life/"}],"tags":[{"name":"mood","slug":"mood","permalink":"https://www.cuicui88.com/tags/mood/"}]},{"title":"学习打卡-2019.3.25","slug":"2019-3-25-complete","date":"2019-03-25T14:52:31.000Z","updated":"2019-03-25T15:18:59.228Z","comments":true,"path":"2019/03/25/2019-3-25-complete/","link":"","permalink":"https://www.cuicui88.com/2019/03/25/2019-3-25-complete/","excerpt":"爱学习，爱探索","text":"爱学习，爱探索 完成了在博客中添加音乐的功能。 解决了谷歌浏览器无法通过fiddler进行重定向获取本地数据的问题！！！开心到飞起~~","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"fiddler 音乐","slug":"fiddler-音乐","permalink":"https://www.cuicui88.com/tags/fiddler-音乐/"}]},{"title":"观比悲伤更悲伤的故事","slug":"lifeMoive","date":"2019-03-25T03:51:30.000Z","updated":"2019-03-25T09:09:23.364Z","comments":true,"path":"2019/03/25/lifeMoive/","link":"","permalink":"https://www.cuicui88.com/2019/03/25/lifeMoive/","excerpt":"爱生活，爱电影","text":"爱生活，爱电影 &emsp;以前看过韩版的比悲伤更悲伤的故事，只记得当时被故事感动地一塌糊涂，其余电影中的各种情节都不太记得了。 &emsp;这次怀着好奇的心情去看了台湾拍的这部与韩国同名的爱情电影，电影中男主为女主所做的一切切实让人感动。男主得知自己的病情之后，即便与女主同住一个屋檐下十几年，也没有跟女主确立男女朋友关系。并且为女主以后生活的幸福付出了太多太多。而女主也一直知道男主的病情与付出，但是她并没有向男主坦白，直到男主快要去世的时候，她才丢下了男主为她安排的一切，去照顾男主。并选择在男主去世的之后选择了追随男主而去。最终与男主永远幸福快乐地生活在了一起。 &emsp;最后，强烈推荐这部剧中的由天生歌姬A-Lin演唱的歌曲《有一种悲伤》。","categories":[{"name":"life","slug":"life","permalink":"https://www.cuicui88.com/categories/life/"}],"tags":[{"name":"moive","slug":"moive","permalink":"https://www.cuicui88.com/tags/moive/"}]}]}