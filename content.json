{"meta":{"title":"木槿少年的博客","subtitle":"每一个不曾起舞的日子都是对生命的辜负","description":"前端学习","author":"winnie","url":"https://www.cuicui88.com","root":"/"},"pages":[],"posts":[{"title":"leetcode-494-538","slug":"leetcode-494-538","date":"2019-10-21T03:49:17.000Z","updated":"2019-10-21T04:03:35.301Z","comments":true,"path":"2019/10/21/leetcode-494-538/","link":"","permalink":"https://www.cuicui88.com/2019/10/21/leetcode-494-538/","excerpt":"leetcode 494 538题","text":"leetcode 494 538题 leetcode 494题题目：给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 解答：123456789101112131415161718192021var findTargetSumWays = function(nums, S) &#123; var sum = 0; for(var i=0;i&lt;nums.length;i++)&#123; sum = sum + nums[i]; &#125; if(sum&lt;S||(sum+S)%2!=0)&#123; return 0; &#125; var arr = []; var w = parseInt((sum+S)/2); for(var j=0;j&lt;w+1;j++)&#123; arr[j] = 0; &#125; arr[0] = 1; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=w;j&gt;=nums[i];j--)&#123; arr[j] = arr[j] + arr[j-nums[i]]; &#125; &#125; return arr[w];&#125;; leetcode538题题目：给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 解答：1234567891011121314var convertBST = function(root) &#123; var num = 0; function convert1(root)&#123; if(root==null)&#123; return; &#125; convert1(root.right); root.val = root.val + num; num = root.val; convert1(root.left); &#125; convert1(root); return root;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-543-560","slug":"leetcode-543-560","date":"2019-10-18T07:33:22.000Z","updated":"2019-10-18T07:45:27.532Z","comments":true,"path":"2019/10/18/leetcode-543-560/","link":"","permalink":"https://www.cuicui88.com/2019/10/18/leetcode-543-560/","excerpt":"leetcode 543 560题","text":"leetcode 543 560题 leetcode543题题目：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 解答：123456789101112131415var diameterOfBinaryTree = function(root) &#123; var result = 0; deep(root); return result; function deep(root)&#123; if(!root)&#123; return -1; &#125; var left = root.left?deep(root.left)+1:0; var right = root.right?deep(root.right)+1:0; result = Math.max(left+right,result); return Math.max(left,right); &#125;&#125;; leetcode 560题题目：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例：&nbsp;&nbsp;&nbsp;&nbsp;输入：nums = [1,1,1],k=2 &nbsp;&nbsp;&nbsp;&nbsp;输出：2, [1,1]与[1,1]为两种不同的情况。 解答：12345678910111213var subarraySum = function(nums, k) &#123; var count = 0; for(var i=0;i&lt;nums.length;i++)&#123; var sum = 0; for(var j=i;j&lt;nums.length;j++)&#123; sum += nums[j]; if(sum==k)&#123; count++; &#125; &#125; &#125; return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-572-581","slug":"leetcode-572-581","date":"2019-10-16T13:38:51.000Z","updated":"2019-10-16T14:09:44.320Z","comments":true,"path":"2019/10/16/leetcode-572-581/","link":"","permalink":"https://www.cuicui88.com/2019/10/16/leetcode-572-581/","excerpt":"leetcode 572 581题","text":"leetcode 572 581题 leetcode572题题目：给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 解答： 先定义一个函数isCommon，这个函数用来判断两个树是否是相等的。 然后在isSubtree这个函数中，首先判断s是否为null，如果为null，返回false；如果s和t经isCommon这个函数判断是相同的，那么返回true；否则去判断，s.left里面是否包含树t或者s.right里面是否包含树t。 123456789101112131415161718192021var isSubtree = function(s, t) &#123; if(!s)&#123; return false; &#125; if(isCommon(s,t))&#123; return true; &#125; return isSubtree(s.left,t)||isSubtree(s.right,t);&#125;;function isCommon(s,t)&#123; if(!s&amp;&amp;!t)&#123; return true; &#125; if(!s||!t)&#123; return false; &#125; if(s.val!==t.val)&#123; return false; &#125; return isCommon(s.left,t.left)&amp;&amp;isCommon(s.right,t.right);&#125; leetcode581题题目：给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例：&nbsp;&nbsp;&nbsp;&nbsp;输入: [2, 6, 4, 8, 10, 9, 15]&nbsp;&nbsp;&nbsp;&nbsp;输出: 5&nbsp;&nbsp;&nbsp;&nbsp;解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 解答：分为两个步骤： 遍历整个数组元素，确定最终的high值。如果是数组的第一个元素，那么将maxValue值确定为该值，如果不是，将nums[i]值与maxValue值进行比较，如果小于maxValue，代表这个值是乱序中的一个，故此时的high值为这个元素对应的i；无论是否小于maxValue，我们都需要重新确定maxValue值，这个值为现在的maxValue值与nums[i]两者最大值。 同上面，遍历整个数组元素，确定最终的low值。如果是数组的最后一个元素，将minValue确定为该值，如果不是，将nums[i]与minValue值进行比较，如果大于minValue，代表这个值是乱序中的一个，故此时的low值为这个元素对应的i；无论是否大于minValue，我们都需要重新确定maxValue值，这个值为现在的minValue值与nums[i]两者的最小值。 确定了low和high，就可以通过两者的差值再加1得到最终的乱序序列长度。 123456789101112131415161718192021222324252627282930var findUnsortedSubarray = function(nums) &#123; if(nums.length==0||nums.length==1)&#123; return 0; &#125; var maxValue; var minValue; var high = 0; var low = 1; for(var i=0;i&lt;nums.length;i++)&#123; if(i==0)&#123; maxValue = nums[i]; &#125;else&#123; if(nums[i]&lt;maxValue)&#123; high = i; &#125; maxValue = Math.max(nums[i],maxValue); &#125; &#125; for(var i=nums.length-1;i&gt;=0;i--)&#123; if(i==nums.length-1)&#123; minValue = nums[i]; &#125;else&#123; if(nums[i]&gt;minValue)&#123; low = i; &#125; minValue = Math.min(nums[i],minValue); &#125; &#125; return high-low+1;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-617-621","slug":"leetcode-617-621","date":"2019-10-15T13:51:56.000Z","updated":"2019-10-15T14:08:28.576Z","comments":true,"path":"2019/10/15/leetcode-617-621/","link":"","permalink":"https://www.cuicui88.com/2019/10/15/leetcode-617-621/","excerpt":"leetcode 617题 621题","text":"leetcode 617题 621题 leetcode617题题目给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 解答：123456789101112var mergeTrees = function(t1, t2) &#123; if(t1==null)&#123; return t2; &#125; if(t2==null)&#123; return t1; &#125; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); return t1;&#125;; leetcode621题题目：给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例:&nbsp;&nbsp;&nbsp;&nbsp;输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2&nbsp;&nbsp;&nbsp;&nbsp;输出: 8&nbsp;&nbsp;&nbsp;&nbsp;执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 解答：123456789101112131415161718192021222324var leastInterval = function(tasks, n) &#123; var obj = &#123;&#125;; for(var i=0;i&lt;tasks.length;i++)&#123; if(obj[tasks[i]]!=undefined)&#123; obj[tasks[i]]++; &#125;else&#123; obj[tasks[i]]=1; &#125; &#125; var maxValue = 0; var count=0; for(var key in obj)&#123; if(maxValue&lt;obj[key])&#123; maxValue = obj[key]; &#125; &#125; for(var key in obj)&#123; if(maxValue==obj[key])&#123; count++; &#125; &#125; return Math.max.call(null,tasks.length,(maxValue-1)*(n+1)+count);&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode 647 771","slug":"leetcode-647-771","date":"2019-10-14T13:26:01.000Z","updated":"2019-10-15T14:12:43.227Z","comments":true,"path":"2019/10/14/leetcode-647-771/","link":"","permalink":"https://www.cuicui88.com/2019/10/14/leetcode-647-771/","excerpt":"leetcode 647题 771题","text":"leetcode 647题 771题 leetcode 647题 题目：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例1： &emsp;&emsp;输入: “abc” &emsp;&emsp;输出: 3 &emsp;&emsp;解释: 三个回文子串: “a”, “b”, “c”. 示例2： &emsp;&emsp;输入: “aaa” &emsp;&emsp;输出: 6 &emsp;&emsp;说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 解答1（复杂度高的版本）：1234567891011121314151617181920212223242526var countSubstrings = function(s) &#123; var count = s.length; for(var len=2;len&lt;=s.length;len++)&#123; for(var i=0;i&lt;=s.length-len;i++)&#123; var subStr = s.substr(i,len); if(judge(subStr))&#123; count++; &#125; &#125; &#125; return count;&#125;;//首先判断一个字符串是否为回文子串function judge(s)&#123; var s = s.split(&apos;&apos;); if(s.length==1)&#123; return true; &#125; for(var i=0;i&lt;parseInt(s.length/2);i++)&#123; if(s[i]!=s[s.length-1-i])&#123; return false; &#125; &#125; return true;&#125; 解答2（复杂度低的版本）：1234567891011121314151617var countSubstrings = function(s) &#123; var count = 0; for(var i=0;i&lt;=s.length;i++)&#123; count += countSinglePoint(s,i,i);//计算子串长度为奇数对应的回文子串个数 count += countSinglePoint(s,i,i+1);//计算子串长度为偶数对应的回文子串个数 &#125; return count;&#125;;function countSinglePoint(s,i,j)&#123; var num = 0; while(i&gt;=0&amp;&amp;j&lt;s.length&amp;&amp;s[i]==s[j])&#123; i--; j++; num++; &#125; return num;&#125; leetcode771题题目：给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例1： &emsp;&emsp;输入: J = “aA”, S = “aAAbbbb” &emsp;&emsp;输出: 3 示例2： &emsp;&emsp;输入：J = “z”, S = “ZZ” &emsp;&emsp;输出：0 解答1：1234567891011121314var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); var count = 0; for(var i=0;i&lt;str2.length;i++)&#123; for(var j=0;j&lt;str1.length;j++)&#123; if(str2[i]==str1[j])&#123; count++; break; &#125; &#125; &#125; return count;&#125;; 解答2：123456789101112131415var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); var obj = &#123;&#125;; var count = 0; for(var i=0;i&lt;str1.length;i++)&#123; obj[str1[i]] = 1; &#125; for(var j=0;j&lt;str2.length;j++)&#123; if(obj[str2[j]]==1)&#123; count++; &#125; &#125; return count;&#125; 解答3：12345var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); return str2.filter(item=&gt;str1.includes(item)).length;&#125;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"实习面试-微众银行","slug":"micro-public-bank-interview","date":"2019-04-17T09:17:16.000Z","updated":"2019-04-17T09:32:09.365Z","comments":true,"path":"2019/04/17/micro-public-bank-interview/","link":"","permalink":"https://www.cuicui88.com/2019/04/17/micro-public-bank-interview/","excerpt":"微众银行面试凉经","text":"微众银行面试凉经 微众银行面试凉凉： 面试官首先说我的简历太过于简陋（我记得自己是上传了的，感觉很神奇。事后我打开官网看了一下，啥都没有，我也是很迷茫。。） 然后问我有没有做过什么项目，接触过前端的框架没有，我说接触过react，然后用react去模仿了简书的网页。面试官问我项目有没有上线呀什么的，我说没有，只是拿来练手的。然后面试官问我项目中有没有涉及到关于逻辑业务的部分，比如登录注册页面的实现什么的，我说没（还说了通过访问json从后台获取数据这算不算）。估计对项目这里确实是绝望透顶了吧，所以说下面开始问基础知识。————-目测这里就凉了一大截了！！！ 问我平时看什么书，我说我看的是红宝书-javascript高级程序设计，然后就让我解释一下原型链，我解释了一下。然后面试官说我基础还不错。 中途因为我的电脑网速太慢，切到了手机上面试（面试官说他本来要让编程的，编程的话，主要好像是要做链表和字符串的编程，现在想想，我还是手写代码写的太少了，然后算法的准备也不充足–》面试之前只准备了快速排序，冒泡排序还有深度遍历和广度遍历）。然后问了我赛马问题，我当时一脸懵，对于完全没有看过这个题的我感觉很难，然后一切就这样结束了。 又是不到20分钟的一场面试，综合来看，这段时间基础复习得还算可以了。但是项目方面，真的是一言难尽。前后端的这些交互啊什么的，是必须要的（突然想起来师兄说：他到公司就会做项目。现在才意识到自己这方面的不足）。然后就是算法题方面，虽然因为电脑网速的原因没有敲代码（虽然我感觉就算我敲也敲不出来哈哈哈），但是肯定欠缺很大。智力题的话，我实在是没辙啊！！ 综上，现在要准备的是算法题和项目，算法题的话，每天两道前端的算法题，滚瓜烂熟。然后项目的话，要去实现一些复杂的功能，不然面试官会很无语的，面啥挂啥！！","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.cuicui88.com/tags/面试/"}]},{"title":"mood-2019-3-27","slug":"mood-2019-3-27","date":"2019-03-27T04:05:07.000Z","updated":"2019-03-27T05:58:10.764Z","comments":true,"path":"2019/03/27/mood-2019-3-27/","link":"","permalink":"https://www.cuicui88.com/2019/03/27/mood-2019-3-27/","excerpt":"今天任务完成的不太好","text":"今天任务完成的不太好 &emsp;今天老师叫我们去提交任务完成情况的时候，我匆匆忙忙，并没有将老师需要我们提交的内容整理出来。因为几乎忘记了老师之前要求我做的事情。包括写方案分析和报告以及关于搜索唤醒词识别的相关内容（我做的事情是继续老师上一次布置的任务）。 &emsp;事实证明，先弄完老师东西，再去做自己的事情，才是比较正确的，不然会心力交瘁！","categories":[{"name":"life","slug":"life","permalink":"https://www.cuicui88.com/categories/life/"}],"tags":[{"name":"mood","slug":"mood","permalink":"https://www.cuicui88.com/tags/mood/"}]},{"title":"学习打卡-2019.3.25","slug":"2019-3-25-complete","date":"2019-03-25T14:52:31.000Z","updated":"2019-03-25T15:18:59.228Z","comments":true,"path":"2019/03/25/2019-3-25-complete/","link":"","permalink":"https://www.cuicui88.com/2019/03/25/2019-3-25-complete/","excerpt":"爱学习，爱探索","text":"爱学习，爱探索 完成了在博客中添加音乐的功能。 解决了谷歌浏览器无法通过fiddler进行重定向获取本地数据的问题！！！开心到飞起~~","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"fiddler 音乐","slug":"fiddler-音乐","permalink":"https://www.cuicui88.com/tags/fiddler-音乐/"}]},{"title":"观比悲伤更悲伤的故事","slug":"lifeMoive","date":"2019-03-25T03:51:30.000Z","updated":"2019-03-25T09:09:23.364Z","comments":true,"path":"2019/03/25/lifeMoive/","link":"","permalink":"https://www.cuicui88.com/2019/03/25/lifeMoive/","excerpt":"爱生活，爱电影","text":"爱生活，爱电影 &emsp;以前看过韩版的比悲伤更悲伤的故事，只记得当时被故事感动地一塌糊涂，其余电影中的各种情节都不太记得了。 &emsp;这次怀着好奇的心情去看了台湾拍的这部与韩国同名的爱情电影，电影中男主为女主所做的一切切实让人感动。男主得知自己的病情之后，即便与女主同住一个屋檐下十几年，也没有跟女主确立男女朋友关系。并且为女主以后生活的幸福付出了太多太多。而女主也一直知道男主的病情与付出，但是她并没有向男主坦白，直到男主快要去世的时候，她才丢下了男主为她安排的一切，去照顾男主。并选择在男主去世的之后选择了追随男主而去。最终与男主永远幸福快乐地生活在了一起。 &emsp;最后，强烈推荐这部剧中的由天生歌姬A-Lin演唱的歌曲《有一种悲伤》。","categories":[{"name":"life","slug":"life","permalink":"https://www.cuicui88.com/categories/life/"}],"tags":[{"name":"moive","slug":"moive","permalink":"https://www.cuicui88.com/tags/moive/"}]}]}