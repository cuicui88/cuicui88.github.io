{"meta":{"title":"木槿少年的博客","subtitle":"每一个不曾起舞的日子都是对生命的辜负","description":"前端学习","author":"winnie","url":"https://www.cuicui88.com","root":"/"},"pages":[],"posts":[{"title":"leetcode-124-128","slug":"leetcode-124-128","date":"2019-11-20T02:28:10.000Z","updated":"2019-11-20T02:42:05.697Z","comments":true,"path":"2019/11/20/leetcode-124-128/","link":"","permalink":"https://www.cuicui88.com/2019/11/20/leetcode-124-128/","excerpt":"","text":"leetcode124题128题leetcode124题（二叉树中的最大路径和）：给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例： 解答：123456789101112131415var maxPathSum = function(root) &#123; var maxSum = -Infinity; function maxGain(root)&#123;//包含根节点的一边最大路径和 if(root==null)&#123;//如果节点不存在，返回0 return 0; &#125; var left_gain = Math.max(maxGain(root.left),0);//左边的最大路径和 var right_gain = Math.max(maxGain(root.right),0);//右边的最大路径和 var newPathGain = root.val + left_gain + right_gain;//包含根节点在内的两边最大路径和 maxSum = Math.max(maxSum,newPathGain);//取二者最大值 return root.val+Math.max(left_gain,right_gain);// &#125; maxGain(root); return maxSum;&#125;; leetcode128题（最长连续序列）：给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例：输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 解答：12345678910111213141516171819var longestConsecutive = function(nums) &#123; var obj = &#123;&#125;; for(var i=0;i&lt;nums.length;i++)&#123; obj[nums[i]] = nums[i]; &#125; var maxLength = 0; for(var prop in obj)&#123; if(obj[prop-1]==undefined)&#123; var curNum = obj[prop]; var curLength = 1; while(obj[curNum+1]!=undefined)&#123; curLength++; curNum = curNum+1; &#125; maxLength = Math.max(curLength,maxLength); &#125; &#125; return maxLength;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-136-139-141","slug":"leetcode-136-139-141","date":"2019-11-19T02:27:54.000Z","updated":"2019-11-19T02:40:36.050Z","comments":true,"path":"2019/11/19/leetcode-136-139-141/","link":"","permalink":"https://www.cuicui88.com/2019/11/19/leetcode-136-139-141/","excerpt":"leetcode136题139题141题","text":"leetcode136题139题141题 leetcode136题（只出现一次的数字）：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 示例：输入：[2,2,1] 输出：1 输入：[4,1,2,1,2] 输出：4 解答：1234567891011121314151617181920212223242526272829303132//方法1var singleNumber = function(nums) &#123; for(var i=0;i&lt;nums.length;i++)&#123; if(nums.indexOf(nums[i])==nums.lastIndexOf(nums[i]))&#123; return nums[i]; &#125; &#125;&#125;;//方法2var singleNumber = function(nums) &#123; obj = &#123;&#125;; for(var i=0;i&lt;nums.length;i++)&#123; if(obj[nums[i]]==undefined)&#123; obj[nums[i]]=1; &#125;else&#123; obj[nums[i]]++; &#125; &#125; for(var prop in obj)&#123; if(obj[prop]==1)&#123; return prop; &#125; &#125;&#125;;//方法3var singleNumber = function(nums) &#123; var ans = 0; for(var i=0;i&lt;nums.length;i++)&#123; ans = ans^nums[i];//一个数与0异或得到自己，与自己异或得到零（因此出现两次的自己与自己异或之后得到0） &#125; return ans;&#125;; leetcode139题（单词拆分）：给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词 示例：输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出: false 解答（动态规划）：12345678910111213141516var wordBreak = function(s, wordDict) &#123; var dp = [];//代表以该下标之前的字符串是否可由字典表组成 dp[0] = true; for(var i=1;i&lt;=s.length;i++)&#123; dp[i] = false; &#125; for(var i=1;i&lt;=s.length;i++)&#123; for(var j=0;j&lt;i;j++)&#123; if(dp[j]&amp;&amp;(wordDict.indexOf(s.slice(j,i))!=-1))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length];&#125;; leetcode141题（环形链表）：给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例： 解答（可参考142题）：123456789101112var hasCycle = function(head) &#123; var slow = head; var fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; if(slow==fast)&#123; return true; &#125; &#125; return false;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-142-146","slug":"leetcode-142-146","date":"2019-11-18T03:50:35.000Z","updated":"2019-11-18T04:18:38.387Z","comments":true,"path":"2019/11/18/leetcode-142-146/","link":"","permalink":"https://www.cuicui88.com/2019/11/18/leetcode-142-146/","excerpt":"leetcode142题146题：","text":"leetcode142题146题： leetcode142题（环形链表）：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例： 解答（双指针法）：假设非环部分的长度是x，从环起点到相遇点的长度是y。环的长度是c。现在走的慢的那个指针走过的长度肯定是x+n1c+y，走的快的那个指针的速度是走的慢的那个指针速度的两倍。这意味着走的快的那个指针走的长度是2(x+n1c+y)。 还有一个约束就是走的快的那个指针比走的慢的那个指针多走的路程一定是环长度的整数倍。根据上面那个式子可以知道2(x+n1c+y)-x+n1c+y=x+n1c+y=n2c。 所以有x+y=(n2-n1)*c,这意味着什么？我们解读下这个数学公式：非环部分的长度+环起点到相遇点之间的长度就是环的整数倍。这在数据结构上的意义是什么？现在我们知道两个指针都在离环起点距离是y的那个相遇点，而现在x+y是环长度的整数倍，这意味着他们从相遇点再走x距离就刚刚走了很多圈，这意味着他们如果从相遇点再走x就到了起点。那怎么才能再走x步呢？答：让一个指针从头部开始走，另一个指针从相遇点走，等这两个指针相遇那就走了x步此时就是环的起点。 1234567891011121314151617var detectCycle = function(head) &#123; var slow = head; var fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; if(slow == fast)&#123;//slow和fast能够相遇就表明必定有环存在 fast = head;//让fast重新从头指针开始，再次与slow相遇的位置就是环起点的位置 while(slow!=fast)&#123; slow = slow.next; fast = fast.next; &#125; return fast; &#125; &#125; return null;&#125;; leetcode146题（LRU缓存机制）：运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 示例：123456789101112131415LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解答：使用js的对象和双向链表解决;使用js的Map对象解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//利用对象和双向链表解决/** * @param &#123;number&#125; capacity */var LRUCache = function(capacity) &#123; this.capacity = capacity; this.obj = &#123;&#125;;//obj中存储链表节点 //新建两个节点，head和tail，head后面存旧的元素，tail前面存新的元素 this.head = new listNode(); this.tail = new listNode(); //初始化链表 this.head.next = this.tail; this.tail.prev = this.head;&#125;;var listNode = function(key,val)&#123;//定义双向链表节点 this.key = key; this.val = val; this.prev = null; this.next = null;&#125;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function(key) &#123; if(this.obj[key]!=undefined)&#123;//如果存在于对象中,将其放在链表末尾,同时返回其对应的值 this.moveToTail(key); return this.obj[key].val; &#125; return -1;//否则直接返回-1&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function(key, value) &#123; if(this.obj[key]!=undefined)&#123;//如果存在于对象中,就不需要在链表中添加新的节点 //直接更新对象中的对应值,直接将其放在链表尾部即可 this.obj[key].val = value; this.moveToTail(key); &#125;else&#123; var length = 0; for(var prop in this.obj)&#123;//计算对象长度 length++; &#125; if(length==this.capacity)&#123;//如果长度与容量相等，需要删除链表中的节点 delete this.obj[this.head.next.key]; this.head.next = this.head.next.next; this.head.next.prev = this.head; &#125; var newNode = new listNode(key,value);//删除之后，将新的节点添加到链表尾部 this.obj[key] = newNode; newNode.prev = this.tail.prev; newNode.next = this.tail; this.tail.prev.next = newNode; this.tail.prev = newNode; &#125;&#125;;//将节点移动到链表尾部的函数LRUCache.prototype.moveToTail = function(key) &#123; node = this.obj[key]; node.prev.next = node.next; node.next.prev = node.prev; node.prev = this.tail.prev; node.next = this.tail; this.tail.prev.next = node; this.tail.prev = node;&#125;/** * Your LRUCache object will be instantiated and called as such: * var obj = new LRUCache(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */ 1234567891011121314151617181920212223242526//利用js的map数据结构解决var LRUCache = function(capacity) &#123; this.cache = new Map();//一个Map对象在迭代时会根据对象中元素的插入顺序来进行 this.capacity = capacity;&#125;LRUCache.prototype.get = function(key, value) &#123; let cache = this.cache; if (cache.has(key)) &#123; let temp = cache.get(key) cache.delete(key); cache.set(key, temp);//设置新值，相当于插入，那么会在最前面 return temp; &#125; else &#123; return -1; &#125;&#125;LRUCache.prototype.put = function(key, value) &#123; let cache = this.cache; if (cache.has(key)) &#123; cache.delete(key); &#125; else if (cache.size &gt;= this.capacity) &#123;//如果此时容量与最大容量相等，那么需要删掉第一个 cache.delete(cache.keys().next().value); //next()方法，调用返回一个包含两个属性的对象，分别是value和done，value表示当前位置的值，done表示是否迭代完，当为true的时候，调用next就无效了。 &#125; cache.set(key, value);&#125;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-148-152","slug":"leetcode-148-152","date":"2019-11-15T02:17:28.000Z","updated":"2019-11-15T02:42:13.486Z","comments":true,"path":"2019/11/15/leetcode-148-152/","link":"","permalink":"https://www.cuicui88.com/2019/11/15/leetcode-148-152/","excerpt":"leetcode148题152题：","text":"leetcode148题152题： leetcode148题（排序链表）：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例：输入：4-&gt;2-&gt;1-&gt;3 输出：1-&gt;2-&gt;3-&gt;4 输入：-1-&gt;5-&gt;3-&gt;4-&gt;0 输出：-1-&gt;0-&gt;3-&gt;4-&gt;5 解答：当题目输入的 head == Null 时，直接返回Null。 通过递归实现链表归并排序，有以下两个环节： 分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）； 我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。 找到中点 slow 后，执行 slow.next = Null 将链表切断。 递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 mid(因为链表是从 slow 切断的)。 cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。 合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。 双指针法合并，建立辅助ListNode res(h) 作为头部。 设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。 返回辅助ListNode h 作为头部的下个节点 h.next。 时间复杂度 O(l + r)，l, r 分别代表两个链表长度。 1234567891011121314151617181920212223242526272829303132333435var sortList = function(head) &#123;//首先进行分割，递归分割为两个链表，然后进行合并排序 if(head==null||head.next==null)&#123; return head; &#125; var slow = head; var fast = head.next; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; var mid = slow.next; slow.next = null; //以上将链表分割为两个链表 var left = sortList(head);//得到左边链表的排序结果 var right = sortList(mid);//得到右边链表的排序结果 //对两个已经有序的链表进行排序 var res = new ListNode(null); var h = res; while(left!=null&amp;&amp;right!=null)&#123; if(left.val&lt;right.val)&#123; res.next = left; left = left.next; &#125;else&#123; res.next = right; right = right.next; &#125; res = res.next; &#125; if(left==null)&#123; res.next = right; &#125;else&#123; res.next = left; &#125; return h.next;&#125;; leetcode152题（乘积最大子序列）：给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例：输入：[2,3,-2,4] 输出：6 解释：子数组[2,3]有最大乘积6. 输入：[-2,0,-1] 输出：0 解释：结果不能为2，因为[-2,-1]不是子数组. 解答（动态规划）：1234567891011121314151617181920我们先定义一个数组 dpMax，用 dpMax[i] 表示以第 i 个元素的结尾的子数组，乘积最大的值，也就是这个数组必须包含第 i 个元素。那么 dpMax[i] 的话有以下几种取值：1. 当 nums[i] &gt;= 0 并且dpMax[i-1] &gt; 0，dpMax[i] = dpMax[i-1] * nums[i]2. 当 nums[i] &gt;= 0 并且dpMax[i-1] &lt; 0，此时如果和前边的数累乘的话，会变成负数，所以dpMax[i] = nums[i]当 nums[i] &lt; 0，此时如果前边累乘结果是一个很大的负数，和当前负数累乘的话就会变成一个更大的数。所以我们还需要一个数组 dpMin 来记录以第 i 个元素的结尾的子数组，乘积最小的值。3. 当dpMin[i-1] &lt; 0，dpMax[i] = dpMin[i-1] * nums[i]4. 当dpMin[i-1] &gt;= 0，dpMax[i] = nums[i]当然，上边引入了 dpMin 数组，怎么求 dpMin 其实和上边求 dpMax 的过程其实是一样的。按上边的分析，我们就需要加很多的 if else来判断不同的情况，这里可以用个技巧。我们注意到上边dpMax[i] 的取值无非就是三种，dpMax[i-1] * nums[i]、dpMin[i-1] * nums[i] 以及 nums[i]。所以我们更新的时候，无需去区分当前是哪种情况，只需要从三个取值中选一个最大的即可。dpMax[i] = max(dpMax[i-1] * nums[i], dpMin[i-1] * nums[i], nums[i]);求 dpMin[i] 同理。dpMin[i] = min(dpMax[i-1] * nums[i], dpMin[i-1] * nums[i], nums[i]);更新过程中，我们可以用一个变量 max 去保存当前得到的最大值。 123456789101112var maxProduct = function(nums) &#123; var dpMax = nums[0]; var dpMin = nums[0]; var max = nums[0]; for(var i=1;i&lt;nums.length;i++)&#123; var preMax = dpMax; dpMax = Math.max(dpMax*nums[i],nums[i],dpMin*nums[i]); dpMin = Math.min(preMax*nums[i],nums[i],dpMin*nums[i]); max = Math.max(max,dpMax); &#125; return max;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-155-160","slug":"leetcode-155-160","date":"2019-11-14T02:04:13.000Z","updated":"2019-11-14T02:05:08.794Z","comments":true,"path":"2019/11/14/leetcode-155-160/","link":"","permalink":"https://www.cuicui88.com/2019/11/14/leetcode-155-160/","excerpt":"leetcode155题160题：","text":"leetcode155题160题： leetcode155题（最小栈）：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例：12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解答：12345678910111213141516171819202122232425262728293031323334353637383940/** * initialize your data structure here. */var MinStack = function() &#123; this.stack = []; this.temp = [];//辅助栈&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack.push(x); if(this.temp.length==0||this.temp[this.temp.length-1]&gt;=x)&#123;//保证辅助栈中，数字的排列从大到小（可相等） this.temp.push(x); &#125;&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123;//stack栈一定会pop，对于辅助栈，如果等于栈顶元素，则pop if(this.stack.pop()==this.temp[this.temp.length-1])&#123; this.temp.pop(); &#125;&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123;//取出栈顶元素 return this.stack[this.stack.length-1];&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123;//取出辅助栈的栈顶元素 return this.temp[this.temp.length-1];&#125;; leetcode160题（相交链表）：编写一个程序，找到两个单链表相交的起始节点。 示例： 解答：采用双指针的方法。 我们可以将a和b两个链表强行串联起来，变成一个8字的形状。 然后我们定义两个指针，一个从a链表头出发，一个从b链表头出发，因为是环形的，最终两个链表会相遇，而相遇的节点就是相交的节点 。 123456789var getIntersectionNode = function(headA, headB) &#123; var a = headA; var b = headB; while(a!=b)&#123; a = (a==null)?headB:a.next;//当a到头的时候，转到headB上去 b = (b==null)?headA:b.next;//当b到头的时候，转到headA上去 &#125; return a;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-169-198","slug":"leetcode-169-198","date":"2019-11-13T01:03:31.000Z","updated":"2019-11-13T01:14:17.836Z","comments":true,"path":"2019/11/13/leetcode-169-198/","link":"","permalink":"https://www.cuicui88.com/2019/11/13/leetcode-169-198/","excerpt":"leetcode169题198题：","text":"leetcode169题198题： leetcode169题（求众数）：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例：输入：[3,2,3] 输出：3 输入：[2,2,1,1,1,2,2] 输出：2 解答（通过javascript的对象解决）：12345678910111213141516var majorityElement = function(nums) &#123; var halfN = parseInt(nums.length/2); var obj = &#123;&#125;; for(var i=0;i&lt;nums.length;i++)&#123; if(obj[nums[i]]==undefined)&#123; obj[nums[i]]=1; &#125;else&#123; obj[nums[i]]++; &#125; &#125; for(var prop in obj)&#123; if(obj[prop]&gt;halfN)&#123; return prop; &#125; &#125;&#125;; leetcode198题（打家劫舍）：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例：输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解答（采用动态规划的解法）：1234567891011121314var rob = function(nums) &#123; var dp = []; for(var i=0;i&lt;=nums.length;i++)&#123; dp[i] = 0; &#125; for(var i=1;i&lt;=nums.length;i++)&#123; if(i==1)&#123; dp[i] = nums[i-1]; &#125;else&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]); &#125; &#125; return dp[nums.length];&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-200-206","slug":"leetcode-200-206","date":"2019-11-12T02:15:10.000Z","updated":"2019-11-12T02:24:52.940Z","comments":true,"path":"2019/11/12/leetcode-200-206/","link":"","permalink":"https://www.cuicui88.com/2019/11/12/leetcode-200-206/","excerpt":"leetcode200题206题：","text":"leetcode200题206题： leetcode200题（岛屿的数量）：给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例： 解答：思路：该题可以采用深度优先遍历进行解决；遍历二维数组中的每一个值，当它是’1’的时候，对该位置进行深度优先遍历，将与其连接构成岛屿的所有’1’都置为’0’，那么遍历原本是’1’的位置的元素时，由于其已经是’0’，就不会多计算岛屿的数量。 1234567891011121314151617181920212223242526272829var numIslands = function(grid) &#123; var count = 0; for(var i=0;i&lt;grid.length;i++)&#123; for(var j=0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]==&apos;1&apos;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count;&#125;;function dfs(grid,i,j)&#123; var rowNum = grid.length; var columnNum = grid[0].length; grid[i][j] = &apos;0&apos;; if(i-1&gt;=0&amp;&amp;grid[i-1][j]==&apos;1&apos;)&#123; dfs(grid,i-1,j); &#125; if(j+1&lt;columnNum&amp;&amp;grid[i][j+1]==&apos;1&apos;)&#123; dfs(grid,i,j+1); &#125; if(i+1&lt;rowNum&amp;&amp;grid[i+1][j]==&apos;1&apos;)&#123; dfs(grid,i+1,j); &#125; if(j-1&gt;=0&amp;&amp;grid[i][j-1]==&apos;1&apos;)&#123; dfs(grid,i,j-1); &#125;&#125; leetcode206题（反转链表）：反转一个单链表。 示例：输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解答：1234567891011var reverseList = function(head) &#123; var pre = null; var node = head; while(node!=null)&#123; var next = node.next; node.next = pre; pre = node; node = next; &#125; return pre;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-207-208","slug":"leetcode-207-208","date":"2019-11-11T06:55:37.000Z","updated":"2019-11-11T07:11:17.669Z","comments":true,"path":"2019/11/11/leetcode-207-208/","link":"","permalink":"https://www.cuicui88.com/2019/11/11/leetcode-207-208/","excerpt":"leetcode207题208题：","text":"leetcode207题208题： leetcode207题（课程表）：现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例：输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 解答：这其实是在判断prerequisites中的数组关系能否构成一个有向无环图，需要借助各个元素的入度表和邻接矩阵以及队列得以实现。 123456789101112131415161718192021222324252627282930313233var canFinish = function(numCourses, prerequisites) &#123; var indegrees = [];//入度表 var adjacency = [];//邻接矩阵 for(var i=0;i&lt;numCourses;i++)&#123; adjacency[i] = []; indegrees[i] = 0; &#125; var queue = [];//队列 for(var i=0;i&lt;prerequisites.length;i++)&#123; var arr = prerequisites[i]; //arr[0]是后面要完成的，arr[1]是需要提前完成的 //图中应该是arr[1]指向arr[0]，所以应该是arr[0]的入度加1 indegrees[arr[0]]++;//arr[0]的入度加1 adjacency[arr[1]].push(arr[0]);//arr[1]的指向里面有arr[0] &#125; for(var i=0;i&lt;numCourses;i++)&#123;//将入度为0的点放入队列 if(indegrees[i]==0)&#123; queue.push(i); &#125; &#125; while(queue.length!=0)&#123;//拿出队列中入度为0的点，并将其邻接矩阵的元素的入度减1 var temp = queue.shift(); numCourses--; temp = adjacency[temp]; for(var i=0;i&lt;temp.length;i++)&#123; indegrees[temp[i]]--; if(indegrees[temp[i]]==0)&#123;//如果入度为0，那么该放入队列中 queue.push(temp[i]); &#125; &#125; &#125; return numCourses==0;//如果没有环的话，那么所有元素都会进入队列，那么最终numCourse最终为0&#125;; leetcode208题（实现Trie-前缀树）：实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例：Trie trie = new Trie(); trie.insert(“apple”);trie.search(“apple”); // 返回 truetrie.search(“app”); // 返回 falsetrie.startsWith(“app”); // 返回 truetrie.insert(“app”);trie.search(“app”); // 返回 true 解答：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Initialize your data structure here. */var Trie = function() &#123; this.nextLetters = &#123;&#125;;//将一个节点的向下相连的节点设置为对象中的内容 this.isWord = false;//插入进去的单词的最后一个节点的isWord为true，其它为false，默认为false&#125;;/** * Inserts a word into the trie. * @param &#123;string&#125; word * @return &#123;void&#125; */Trie.prototype.insert = function(word) &#123; var cur = this; var arr = word.split(&apos;&apos;); for(var i=0;i&lt;arr.length;i++)&#123; if(!cur.nextLetters.hasOwnProperty(arr[i]))&#123; cur.nextLetters[arr[i]] = new Trie(); cur = cur.nextLetters[arr[i]]; &#125;else&#123; cur = cur.nextLetters[arr[i]]; &#125; &#125; cur.isWord = true;&#125;;/** * Returns if the word is in the trie. * @param &#123;string&#125; word * @return &#123;boolean&#125; */Trie.prototype.search = function(word) &#123; var cur = this; var arr = word.split(&apos;&apos;); for(var i=0;i&lt;arr.length;i++)&#123; if(cur.nextLetters.hasOwnProperty(arr[i]))&#123; cur = cur.nextLetters[arr[i]]; &#125;else&#123; return false; &#125; &#125; return cur.isWord;&#125;;/** * Returns if there is any word in the trie that starts with the given prefix. * @param &#123;string&#125; prefix * @return &#123;boolean&#125; */Trie.prototype.startsWith = function(prefix) &#123; var cur = this; var arr = prefix.split(&apos;&apos;); for(var i=0;i&lt;arr.length;i++)&#123; if(cur.nextLetters.hasOwnProperty(arr[i]))&#123; cur = cur.nextLetters[arr[i]]; &#125;else&#123; return false; &#125; &#125; return true;&#125;;/** * Your Trie object will be instantiated and called as such: * var obj = new Trie() * obj.insert(word) * var param_2 = obj.search(word) * var param_3 = obj.startsWith(prefix) */","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-215-221","slug":"leetcode-215-221","date":"2019-11-08T03:22:48.000Z","updated":"2019-11-08T03:41:49.670Z","comments":true,"path":"2019/11/08/leetcode-215-221/","link":"","permalink":"https://www.cuicui88.com/2019/11/08/leetcode-215-221/","excerpt":"leetcode215题221题：","text":"leetcode215题221题： leetcode215题（数组中的第K个最大元素）：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例：输入：[3,2,1,5,6,4]和k=6 输出：5 输入：[3,2,3,1,2,4,5,5,6]和k=4 输出：4 解答：12345678910111213141516171819202122232425var findKthLargest = function(nums, k) &#123; return kth(nums,0,nums.length-1,k); function kth(nums,left,right,k)&#123; var start = left; var end = right; var key = nums[start];//表示以第一个元素为参考值 while(start&lt;end)&#123; while(start&lt;end&amp;&amp;nums[end]&lt;=key)&#123; end--; &#125; nums[start]=nums[end];//当出现不小于key的nums[end]时，将其赋值给nums[start] while(start&lt;end&amp;&amp;nums[start]&gt;=key)&#123; start++; &#125; nums[end]=nums[start];//当出现大于key的nums[start]时，将其赋值给nums[end] &#125; if(start==k-1)&#123; return key; &#125; if(start&lt;k-1)&#123; return kth(nums,start+1,right,k); &#125; return kth(nums,left,start-1,k); &#125;&#125;; leetcode221题（最大正方形）：在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例： 解答：dp[i][j]代表以 i,j为正方形右下角的最大边长是多少 动态方程： 在 matrix[i][j] == “1”，情况下 ​ dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 12345678910111213141516171819202122var maximalSquare = function(matrix) &#123; if(matrix.length==0)&#123; return 0; &#125; var max = 0; var dp = []; for(var i=0;i&lt;=matrix.length;i++)&#123; dp[i] = []; for(var j=0;j&lt;=matrix[0].length;j++)&#123; dp[i][j]=0; &#125; &#125; for(var i=1;i&lt;=matrix.length;i++)&#123; for(var j=1;j&lt;=matrix[0].length;j++)&#123; if(matrix[i-1][j-1]==1)&#123; dp[i][j] = Math.min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1; max = Math.max(max,dp[i][j]*dp[i][j]); &#125; &#125; &#125; return max;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-226-234","slug":"leetcode-226-234","date":"2019-11-07T02:06:17.000Z","updated":"2019-11-07T02:19:26.879Z","comments":true,"path":"2019/11/07/leetcode-226-234/","link":"","permalink":"https://www.cuicui88.com/2019/11/07/leetcode-226-234/","excerpt":"leetcode226题234题：","text":"leetcode226题234题： leetcode226题（翻转二叉树）：翻转一棵二叉树。 示例： 解答：123456789101112var invertTree = function(root) &#123; if(root==null)&#123; return root; &#125; var temp = new TreeNode(null); temp = root.left; root.left = root.right; root.right = temp; root.left = invertTree(root.left); root.right = invertTree(root.right); return root;&#125;; leetcode234题：请判断一个链表是否为回文链表。 示例：输入：1-&gt;2 输出：false 输入：1-&gt;2-&gt;2-&gt;1 输出：true 解答：12345678910111213141516171819202122232425262728293031323334var isPalindrome = function(head) &#123; if(head==null||head.next==null)&#123; return true; &#125; var judgeArr = []; var count = 0; var head1 = head; while(head1!=null)&#123; count++; head1 = head1.next; &#125; while(head!=null)&#123; judgeArr.push(head.val); if((count%2==0)&amp;&amp;(head.next!=null)&amp;&amp;(head.val==head.next.val))&#123; head = head.next; break; &#125; if((count%2==1)&amp;&amp;(head.next!=null)&amp;&amp;(head.next.next!=null)&amp;&amp;(head.val==head.next.next.val))&#123; head = head.next.next; break; &#125; head = head.next; &#125; while(head!=null)&#123; if(head.val!=judgeArr.pop())&#123; return false; &#125; head = head.next; &#125; if(judgeArr.length==0)&#123; return true; &#125; return false;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-236-238","slug":"leetcode-236-238","date":"2019-11-06T12:10:03.000Z","updated":"2019-11-06T12:19:37.680Z","comments":true,"path":"2019/11/06/leetcode-236-238/","link":"","permalink":"https://www.cuicui88.com/2019/11/06/leetcode-236-238/","excerpt":"leetcode236题238题：","text":"leetcode236题238题： leetcode236题（二叉树的最近公共祖先）：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例： 解答：1234567891011var lowestCommonAncestor = function(root, p, q) &#123; if(root==null||p==root||q==root)&#123; return root; &#125; var left = lowestCommonAncestor(root.left,p,q); var right = lowestCommonAncestor(root.right,p,q); if(left&amp;&amp;right)&#123; return root; &#125; return left?left:right;&#125;; leetcode238题（除自身以外数组的）：给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例：输入：[1,2,3,4] 输出：[24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 解答：123456789101112131415161718var productExceptSelf = function(nums) &#123; var dp = []; var bp = []; for(var i=0;i&lt;nums.length;i++)&#123; dp[i] = 1; bp[i] = 1; &#125; for(var i=1;i&lt;nums.length;i++)&#123; dp[i] = dp[i-1]*nums[i-1]; &#125; for(var j=nums.length-2;j&gt;=0;j--)&#123; bp[j] = bp[j+1]*nums[j+1]; &#125; for(var i=0;i&lt;nums.length;i++)&#123; dp[i] = dp[i]*bp[i]; &#125; return dp;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-253-240-239","slug":"leetcode-253-240-239","date":"2019-11-05T03:39:58.000Z","updated":"2019-11-05T03:50:46.249Z","comments":true,"path":"2019/11/05/leetcode-253-240-239/","link":"","permalink":"https://www.cuicui88.com/2019/11/05/leetcode-253-240-239/","excerpt":"leetcode239题240题253题","text":"leetcode239题240题253题 leetcode239题（滑动窗口最大值）：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例： 解答：1234567891011var maxSlidingWindow = function(nums, k) &#123; if(nums.length==0)&#123; return []; &#125; var result = []; for(var i=0;i&lt;=nums.length-k;i++)&#123; var tempArr = nums.slice(i,i+k); result.push(Math.max.apply(null,tempArr)); &#125; return result;&#125;; leetcode240题（搜索二维矩阵2）：编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。每列的元素从上到下升序排列。 示例： 解答：123456789101112131415161718192021222324var searchMatrix = function(matrix, target) &#123; if(matrix.length==0||matrix[0].length==0)&#123; return false; &#125; var row = matrix.length; var column = matrix[0].length; var i = row-1; var j = 0; while(i&gt;=0&amp;&amp;j&lt;column)&#123; if(target&lt;matrix[i][j])&#123; if(i==0)&#123; return false; &#125; i--; &#125;else if(target&gt;matrix[i][j])&#123; if(j==column-1)&#123; return false; &#125; j++; &#125;else&#123; return true; &#125; &#125;&#125;; leetcode253题（会议室）：给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。 示例：输入: [[0, 30],[5, 10],[15, 20]] 输出: 2 输入: [[7,10],[2,4]] 输出: 1 解答：1234567891011121314151617181920212223242526272829303132333435function interval(s,e)&#123; this.start = s; this.end = e;&#125;var minMeetingRooms = function(intervals) &#123; var starts = []; var ends = []; for(var i=0;i&lt;intervals.length;i++)&#123; starts.push(intervals[i].start); ends.push(intervals[i].end); &#125; starts.sort(compare); ends.sort(compare); var i=0; var j=0; var activemeetings = 0; var rooms = 0; while(i&lt;intervals.length&amp;&amp;j&lt;intervals.length)&#123; if(starts[i]&lt;ends[j])&#123; activemeetings++; i++; &#125;else&#123; activemeetings--;//因为后面会出现此时的starts[i]小于另外一个ends[j]，所以仍然会++ //但是由于其实是不需要++的，所以此处添加一个++ j++; &#125; rooms = Math.max(rooms,activemeetings); &#125; return rooms;&#125;function compare(a,b)&#123; return a-b;&#125;console.log(minMeetingRooms([new interval(0,30),new interval(5,10),new interval(15,20)]));","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-279-283","slug":"leetcode-279-283","date":"2019-11-04T02:43:46.000Z","updated":"2019-11-04T03:11:05.915Z","comments":true,"path":"2019/11/04/leetcode-279-283/","link":"","permalink":"https://www.cuicui88.com/2019/11/04/leetcode-279-283/","excerpt":"leetcode279题283题","text":"leetcode279题283题 leetcode279题（完全平方数）：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例：输出：n=12 输出：3 解释：12 = 4+4+4 输出：n=13 输出：2 解释：12 = 4+9 解答：12345678910111213var numSquares = function(n) &#123;//动态规划 var dp = []; for(var i=0;i&lt;=n;i++)&#123; dp[i] = 0; &#125; for(var i=1;i&lt;=n;i++)&#123; dp[i] = i;//下面取两个数中的最小值，因此此处需要定义结果最大值 for(var j=0;i-j*j&gt;=0;j++)&#123; dp[i] = Math.min(dp[i],dp[i-j*j]+1); &#125; &#125; return dp[n];&#125;; leetcode283题（移动零）：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例：输入：[0,1,0,3,12] 输出：[1,3,12,0,0] 解答：12345678910111213141516171819var moveZeroes = function(nums) &#123;//复杂度为O(n^2)的解法 for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]==0)&#123;//思想：统计某个为0的数字后面是否还有非零，如果有非零数字，那么执行splice+push的操作（此处需要i--,否则会跳过0后面的数字） var count = 0; for(var j=i;j&lt;nums.length;j++)&#123; if(nums[j]==0)&#123; count++; &#125; &#125; if(count!=nums.length-i)&#123; nums.push(nums[i]); nums.splice(i,1); i--; &#125; &#125; &#125; return nums;&#125;; 123456789101112var moveZeroes = function(nums) &#123;//只设置一个指针，将碰到的非0数字用lastIndex的下标记录在nums中（这个时候前面的0与非0的元素都已经处理了，不会出现覆盖的情况），然后将其与nums原长度之差的最后的地方放置为0 var lastIndex = 0; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]!=0)&#123; nums[lastIndex++] = nums[i]; &#125; &#125; for(var j=lastIndex;j&lt;nums.length;j++)&#123; nums[j] = 0; &#125; return nums;&#125;; 1234567891011var moveZeroes = function(nums) &#123;//采用双指针的方法，slow始终指向最开始的0 for(var slow=0,fast=0;fast&lt;nums.length;fast++)&#123; if(nums[fast]!=0)&#123;//fast指向0后面的第一个非零数进行处理 var temp = nums[fast]; nums[fast] = nums[slow]; nums[slow] = temp; slow++; &#125; &#125; return nums;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-287-297","slug":"leetcode-287-297","date":"2019-11-01T03:05:50.000Z","updated":"2019-11-01T03:16:20.178Z","comments":true,"path":"2019/11/01/leetcode-287-297/","link":"","permalink":"https://www.cuicui88.com/2019/11/01/leetcode-287-297/","excerpt":"leetcode287题297题","text":"leetcode287题297题 leetcode287题题目：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例：输入：[1,3,4,2,2] 输出：2 输入：[3,1,3,4,2] 输出：3 解答：12345678910111213var findDuplicate = function(nums) &#123; var result; nums.sort(compare); for(var i=1;i&lt;nums.length;i++)&#123; if(nums[i]==nums[i-1])&#123; result = nums[i]; &#125; &#125; return result;&#125;;function compare(a,b)&#123; return a-b;&#125; leetcode297题：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例： 解答： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * Encodes a tree to a single string. * * @param &#123;TreeNode&#125; root * @return &#123;string&#125; */var serialize = function(root) &#123; var result = []; function sertalize1(root)&#123;//此处使用深度优先遍历（或先序遍历）来进行实现的 if(root==null)&#123; result.push(&apos;#&apos;); return; &#125; result.push(root.val); sertalize1(root.left); sertalize1(root.right); &#125; sertalize1(root); return result.join(&apos;,&apos;);//输出是用逗号连接起来的字符串 //例题中的例子输出为：&quot;1,2,#,#,3,4,#,#,5,#,#&quot;&#125;;/** * Decodes your encoded data to tree. * * @param &#123;string&#125; data * @return &#123;TreeNode&#125; */var deserialize = function(data) &#123; data = data.split(&quot;,&quot;); var index = 0; function deserializer(data) &#123; if(index &gt; data.length || data[index] === &quot;#&quot;) &#123; return null; &#125; var node = new TreeNode(parseInt(data[index])); index++; node.left = deserializer(data); index++; node.right = deserializer(data); return node; &#125; return deserializer(data);&#125;;/** * Your functions will be called as such: * deserialize(serialize(root)); */","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-300-301-312","slug":"leetcode-300-301-312","date":"2019-10-31T02:58:48.000Z","updated":"2019-10-31T03:18:22.395Z","comments":true,"path":"2019/10/31/leetcode-300-301-312/","link":"","permalink":"https://www.cuicui88.com/2019/10/31/leetcode-300-301-312/","excerpt":"leetcode 300题301题302题","text":"leetcode 300题301题302题 leetcode300题题目（最长上升子序列）：给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例：输入：[10,9,2,5,3,7,101,18] 输出：4 解释：最长的上升子序列是 [2,3,7,101]，它的长度是 4。 解答：12345678910111213141516var lengthOfLIS = function(nums) &#123; var dp = []; for(var h=0;h&lt;nums.length;h++)&#123; dp[h] = 1; &#125; var result = 0; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=0;j&lt;i;j++)&#123; if(nums[i]&gt;nums[j])&#123; dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; result = Math.max(dp[i],result); &#125; return result;&#125;; leetcode301题题目（删除无效的括号）：删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例：输入：”()())()” 输出：[“()()()”, “(())()”] 输入：”(a)())()” 输出：[“(a)()()”, “(a())()”] 输入：”)(“ 输出：[“”] 解答（深度优先遍历）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var removeInvalidParentheses = function(s) &#123; var result = []; return removeInvalidParentheses1(s); function removeInvalidParentheses1(s)&#123; var left = 0; var right = 0; for(var h=0;h&lt;s.length;h++)&#123;//判断其中应该消掉的左右括号数目 var char = s[h]; if(char==&apos;(&apos;)&#123; left++; &#125; if(char==&apos;)&apos;)&#123; if(left&gt;0)&#123; left--; &#125;else&#123; right++; &#125; &#125; &#125; dfs(s,0,left,right); return result; &#125; function dfs(s,start,left,right)&#123;//深度优先遍历进行括号消除 if(left==0&amp;&amp;right==0)&#123; if(check(s))&#123; result.push(s); &#125; return; &#125; for(var i=start;i&lt;s.length;i++)&#123; if(i-1&gt;=start&amp;&amp;s[i]==s[i-1])&#123; continue; &#125; if(left&gt;0&amp;&amp;s[i]==&apos;(&apos;)&#123; dfs(s.substr(0,i)+s.substr(i+1,s.length-i-1),i,left-1,right); &#125; if(right&gt;0&amp;&amp;s[i]==&apos;)&apos;)&#123; dfs(s.substr(0,i)+s.substr(i+1,s.length-i-1),i,left,right-1); &#125; &#125; &#125; function check(s)&#123;//检查是否满足正常括号对 var count = 0; for(var h=0;h&lt;s.length;h++)&#123; var char = s[h]; if(char==&apos;(&apos;)&#123; count++; &#125; if(char==&apos;)&apos;)&#123; count--; if(count&lt;0)&#123; return false; &#125; &#125; &#125; return count==0; &#125;&#125;; leetcode312题题目（戳气球）：有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] nums[i] nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例： 解答：123456789101112131415161718192021var maxCoins = function(nums) &#123; nums.unshift(1); nums.push(1); var length = nums.length; var dp = []; for(var i=0;i&lt;length;i++)&#123; dp[i] = []; for(var j=0;j&lt;length;j++)&#123; dp[i][j] = 0; &#125; &#125; for(var len=2;len&lt;=length;len++)&#123; for(var i=0;i&lt;=length-len;i++)&#123; var j = i+len-1; for(var k=i+1;k&lt;j;k++)&#123; dp[i][j] = Math.max(dp[i][j],nums[i]*nums[k]*nums[j]+dp[i][k]+dp[k][j]); &#125; &#125; &#125; return dp[0][length-1];&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"share-leetcode-121-122-309-714-123-188","slug":"share-leetcode-121-122-309-714-123-188","date":"2019-10-30T02:35:10.000Z","updated":"2019-10-30T03:47:35.023Z","comments":true,"path":"2019/10/30/share-leetcode-121-122-309-714-123-188/","link":"","permalink":"https://www.cuicui88.com/2019/10/30/share-leetcode-121-122-309-714-123-188/","excerpt":"leetcode股票题目121题122题309题714题123题188题","text":"leetcode股票题目121题122题309题714题123题188题 题目列表（题目从易到难）：121. 买卖股票的最佳时机122. 买卖股票的最佳时机 II309. 最佳买卖股票时机含冷冻期714. 买卖股票的最佳时机含手续费123. 买卖股票的最佳时机 III188. 买卖股票的最佳时机 IV解析：&nbsp;&nbsp;&nbsp;&nbsp;这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 &nbsp;&nbsp;&nbsp;&nbsp;第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 1.穷举：&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。 &nbsp;&nbsp;&nbsp;&nbsp;每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。 &nbsp;&nbsp;&nbsp;&nbsp;很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： 123456789dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for 0 &lt;= i &lt; n: for 1 &lt;= k &lt;= K: for s in &#123;0, 1&#125;: dp[i][k][s] = max(buy, sell, rest) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们想求的最终答案是 dp[n-1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。 2.状态转移框架：&nbsp;&nbsp;&nbsp;&nbsp;现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 &nbsp;&nbsp;&nbsp;&nbsp;通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： 12345678910111213dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell )解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy )解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 &nbsp;&nbsp;&nbsp;&nbsp;这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 &nbsp;&nbsp;&nbsp;&nbsp;现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 12345678dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 把上面的状态转移方程总结一下： 1234567base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 具体题目：leetcode121题（k=1）：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例： 题解：直接套状态转移方程，根据 base case，可以做一些化简： 12345678910111213dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i])发现dp[i][0]由前一步的dp[i][0]与dp[i][1]决定（即由dp[i-1][0]与dp[i-1][1]决定），因此可以取消数组的写法：dp_i_0 = max(dp_i_0,dp_i_1+prices[i]);dp_i_1 = max(dp_i_1,-prices[i]); 综上，代码为： 123456789var maxProfit = function(prices) &#123; var dp_i_0 = 0;//相当于设置dp[-1][0]时的值 var dp_i_1 = -Infinity;//相当于设置dp[-1][1]时的值 for(var i=0;i&lt;prices.length;i++)&#123; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,-prices[i]); &#125; return dp_i_0;&#125;; leetcode122题（k=+Infinity）：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例： 题解：123456789dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 发现k是无穷，因此k和k-1是一样大小的。发现dp[i][0]由前一步的dp[i][0]与dp[i][1]决定（即由dp[i-1][0]与dp[i-1][1]决定），因此可以取消数组的写法：var temp = dp_i_0;dp_i_0 = max(dp_i_0,dp_i_1+prices[i]);dp_i_1 = max(dp_i_1,temp-prices[i]); 代码如下：12345678910var maxProfit = function(prices) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,temp-prices[i]); &#125; return dp_i_0;&#125;; leetcode309题（k=+Infinity含冷冻期）：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例： 题解：每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： 123dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。 具体代码： 123456789101112var maxProfit = function(prices) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; var dp_prev = 0; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,dp_prev-prices[i]); dp_prev = temp; &#125; return dp_i_0;&#125;; leetcode714题（k=+Infinity 含手续费）：给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 示例： 题解：每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： 1234dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)解释：相当于买入股票的价格升高了。在第一个式子里减也是一样的，相当于卖出股票的价格减小了。 代码实现：12345678910var maxProfit = function(prices, fee) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]-fee); dp_i_1 = Math.max(dp_i_1,temp-prices[i]); &#125; return dp_i_0;&#125;; leetcode123题（k=2）：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例： 题解：k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。 123456789原始的动态转移方程，没有可化简的地方dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) 代码实现：12345678910111213var maxProfit = function(prices) &#123; var dp_i_20 = 0; var dp_i_10 = 0; var dp_i_21 = -Infinity; var dp_i_11 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; dp_i_20 = Math.max(dp_i_20,dp_i_21+prices[i]); dp_i_21 = Math.max(dp_i_21,dp_i_10-prices[i]); dp_i_10 = Math.max(dp_i_10,dp_i_11+prices[i]); dp_i_11 = Math.max(dp_i_11,-prices[i]); &#125; return dp_i_20;&#125;; leetcode188题（k=k）：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例： 题解：有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 代码实现：12345678910111213141516171819202122232425262728var maxProfit = function(k, prices) &#123; if(k&gt;parseInt(prices.length/2))&#123; return maxProfitAnyk(prices); &#125; var dp = []; for(var j=0;j&lt;k+1;j++)&#123; dp[j] = []; dp[j][0]=0; dp[j][1]=-Infinity; &#125; for(var i=0;i&lt;prices.length;i++)&#123; for(var j=k;j&gt;=1;j--)&#123; dp[j][0] = Math.max(dp[j][0],dp[j][1]+prices[i]); dp[j][1] = Math.max(dp[j][1],dp[j-1][0]-prices[i]); &#125; &#125; return dp[k][0];&#125;;var maxProfitAnyk = function(prices) &#123; var dp_i_0 = 0; var dp_i_1 = -Infinity; for(var i=0;i&lt;prices.length;i++)&#123; var temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1+prices[i]); dp_i_1 = Math.max(dp_i_1,temp-prices[i]); &#125; return dp_i_0;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-322-337-338","slug":"leetcode-322-337-338","date":"2019-10-28T11:43:03.000Z","updated":"2019-10-28T11:54:14.444Z","comments":true,"path":"2019/10/28/leetcode-322-337-338/","link":"","permalink":"https://www.cuicui88.com/2019/10/28/leetcode-322-337-338/","excerpt":"leetcode 322题 337题 338题","text":"leetcode 322题 337题 338题 leetcode332题：零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例：输入：coins = [1,2,5],amount = 11 输出：3 解释：11 = 5+5+1 输入：coins = [2], amount = 3 输出：-1 解答：123456789101112131415161718192021var coinChange = function(coins, amount) &#123; if(coins.length==0)&#123; return -1; &#125; var dp = []; for(var i=1;i&lt;=amount;i++)&#123; dp[i] = Infinity; &#125; dp[0] = 0; for(var i=0;i&lt;coins.length;i++)&#123; for(var j=coins[i];j&lt;=amount;j++)&#123; if(dp[j-coins[i]]!=Infinity)&#123; dp[j] = Math.min(dp[j],dp[j-coins[i]]+1); &#125; &#125; &#125; if(dp[amount]!=Infinity)&#123; return dp[amount]; &#125; return -1;&#125;; leetcode337题：打家劫舍III在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例： 解答：12345678910111213var rob = function(root) &#123; if(root==null)&#123; return 0; &#125; var val = 0; if(root.left!=null)&#123; val = val + rob(root.left.left)+rob(root.left.right); &#125; if(root.right!=null)&#123; val = val + rob(root.right.left)+rob(root.right.right); &#125; return Math.max(root.val+val,rob(root.left)+rob(root.right));&#125;; leetcode338题：比特位计数给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例：输入：2 输出：[0,1,1] 输入：5 输出：[0,1,1,2,1,2] 进阶： 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 解答：12345678910111213141516171819202122232425//非进阶版var countBits = function(num) &#123; var result = []; for(var i=0;i&lt;=num;i++)&#123; var bits = i.toString(2); var count = 0; for(var j=0;j&lt;bits.length;j++)&#123; if(bits[j]==&apos;1&apos;)&#123; count++; &#125; &#125; result.push(count); &#125; return result;&#125;;//进阶版/*i &amp; (i - 1)可以去掉i最右边的一个1（如果有），因此 i &amp; (i - 1）是比 i 小的，而且i &amp; (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i &amp; (i - 1)的1的个数加上1.*/var countBits = function(num) &#123; var result = []; result[0] = 0; for(var i=1;i&lt;=num;i++)&#123; result[i] = result[i&amp;(i-1)]+1;//&amp;表示按位与 &#125; return result;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-347-394","slug":"leetcode-347-394","date":"2019-10-25T07:41:57.000Z","updated":"2019-10-25T07:50:23.380Z","comments":true,"path":"2019/10/25/leetcode-347-394/","link":"","permalink":"https://www.cuicui88.com/2019/10/25/leetcode-347-394/","excerpt":"leetcode347题394题","text":"leetcode347题394题 leetcode347题题目：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例：示例1： 输入：nums = [1,1,1,2,2,3], k = 2 输出：[1,2] 示例2： 输入：nums = [1], k = 1 输出：[1] 解答：12345678910111213141516171819202122232425262728var topKFrequent = function(nums, k) &#123; function Node(n,c)&#123; this.num = n; this.count = c; &#125; var obj = &#123;&#125;; for(var i=0;i&lt;nums.length;i++)&#123; if(obj[nums[i]]==undefined)&#123; obj[nums[i]]=new Node(nums[i],1); &#125;else&#123; obj[nums[i]].count++; &#125; &#125; var arr = []; for(var prop in obj)&#123; arr.push(obj[prop]); &#125; arr.sort(compare); var result = []; for(var i=0;i&lt;k;i++)&#123; var index = arr.length-1-i; result.push(arr[index].num); &#125; return result;&#125;;function compare(a,b)&#123; return a.count-b.count;&#125; leetcode394题题目：给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例：s = “3[a]2[bc]”, 返回 “aaabcbc”.s = “3[a2[c]]”, 返回 “accaccacc”.s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”. 解答：1234567891011121314151617181920212223var decodeString = function(s) &#123; while(s.indexOf(&apos;]&apos;)!=-1)&#123; var indexEnd = s.indexOf(&apos;]&apos;); var indexStart = indexEnd; while(s[indexStart]!=&apos;[&apos;)&#123; indexStart--; &#125; var nums = []; var index = indexStart; while(!isNaN(parseInt(s[index-1]))&amp;&amp;index!=0)&#123; nums.push(s[index-1]); index--; &#125; var num = parseInt(nums.reverse().join(&apos;&apos;)); var result = &apos;&apos;; for(var i=0;i&lt;num;i++)&#123; var str = s.substring(indexStart+1,indexEnd); result = result+str; &#125; s = s.substring(0,index)+result+s.substring(indexEnd+1,s.length); &#125; return s;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-406-416","slug":"leetcode-406-416","date":"2019-10-25T01:12:11.000Z","updated":"2019-10-25T01:23:16.851Z","comments":true,"path":"2019/10/25/leetcode-406-416/","link":"","permalink":"https://www.cuicui88.com/2019/10/25/leetcode-406-416/","excerpt":"leetcode 406题 416题","text":"leetcode 406题 416题 leetcode406题题目：假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 示例：输入：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出：[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解答：12345678910111213141516var reconstructQueue = function(people) &#123; var result = []; people.sort(compare); for(var i=0;i&lt;people.length;i++)&#123; var index = people[i][1]; result.splice(index,0,people[i]); &#125; return result;&#125;;function compare(a,b)&#123; if(a[0]==b[0])&#123; return a[1]-b[1]; &#125; return b[0]-a[0];&#125; leetcode416题题目：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100；数组的大小不会超过 200。 示例：示例1： 输入：[1, 5, 11, 5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11]. 示例2： 输入：[1, 2, 3, 5] 输出：false 解释：数组不能分割成两个元素和相等的子集. 解答：123456789101112131415161718192021var canPartition = function(nums) &#123; var sum = 0; for(var h=0;h&lt;nums.length;h++)&#123; sum = sum + nums[h]; &#125; if(sum%2!=0)&#123; return false; &#125; var halfSum = parseInt(sum/2); var arr = []; for(var j=0;j&lt;halfSum+1;j++)&#123; arr[j] = false; &#125; arr[0] = true; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=halfSum;j&gt;=nums[i];j--)&#123; arr[j] = (arr[j]||arr[j-nums[i]])?true:false; &#125; &#125; return arr[halfSum];&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-112-113-437","slug":"leetcode-112-113-437","date":"2019-10-22T14:18:27.000Z","updated":"2019-10-22T15:26:09.851Z","comments":true,"path":"2019/10/22/leetcode-112-113-437/","link":"","permalink":"https://www.cuicui88.com/2019/10/22/leetcode-112-113-437/","excerpt":"leetcode 112题 113题 437题","text":"leetcode 112题 113题 437题 leetcode 112题题目：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 解答：123456789var hasPathSum = function(root, sum) &#123; if(root==null)&#123; return false; &#125; if(root.left==null&amp;&amp;root.right==null)&#123; return sum-root.val==0; &#125; return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);&#125;; leetcode113题题目：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 解答：123456789101112131415161718192021222324var pathSum = function(root, sum) &#123; var result = []; get(root,0,[],result); function get(node,currentSum,currentList,result)&#123; if(node==null)&#123; return; &#125; currentSum = currentSum + node.val; currentList.push(node.val); if(node.left==null&amp;&amp;node.right==null)&#123; if(currentSum==sum)&#123; result.push(JSON.parse(JSON.stringify(currentList))); //console.log(result); &#125; currentList.pop(); return; &#125; get(node.left,currentSum,currentList,result); get(node.right,currentSum,currentList,result); currentList.pop(); &#125; return result;&#125;; leetcode437题题目：给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 解答：123456789101112131415161718192021222324var pathSum = function(root, sum) &#123; var count = 0; function pathSum1(root,sum)&#123; if(root==null)&#123; return 0; &#125; Sum(root,sum); pathSum1(root.left,sum); pathSum1(root.right,sum); &#125; function Sum(root,sum)&#123; if(root==null)&#123; return; &#125; sum = sum - root.val; if(sum==0)&#123; count++; &#125; Sum(root.left,sum); Sum(root.right,sum); &#125; pathSum1(root,sum); return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-448-461","slug":"leetcode-448-461","date":"2019-10-21T12:05:47.000Z","updated":"2019-10-21T12:20:20.768Z","comments":true,"path":"2019/10/21/leetcode-448-461/","link":"","permalink":"https://www.cuicui88.com/2019/10/21/leetcode-448-461/","excerpt":"leetcode 448题 461题","text":"leetcode 448题 461题 leetcode 448题题目：给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例：输入：[4,3,2,7,8,2,3,1] 输出：[5,6] 解答：思路：第一个for循环相当于是将输入数组中，与数组中元素值-1对应位置的数加上数组长度，那么循环结束之后，如果某个位置上的元素值是大于数组长度的，那么代表这个位置上有相应的元素出现，如果是小于或等于的，那么代表没有相应的元素出现。那么返回这个位置值+1。 12345678910111213var findDisappearedNumbers = function(nums) &#123; for(var i=0;i&lt;nums.length;i++)&#123; var index = (nums[i]-1)%nums.length; nums[index] = nums[index] + nums.length; &#125; var res = []; for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&lt;=nums.length)&#123; res.push(i+1); &#125; &#125; return res;&#125;; leetcode 461题题目：两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 解答：123456789101112131415161718192021222324252627//这种方法空间复杂度太高var hammingDistance = function(x, y) &#123; var str1 = x.toString(2); var str2 = y.toString(2); var arr1 = str1.split(&apos;&apos;); var arr2 = str2.split(&apos;&apos;); var len = Math.max(arr1.length,arr2.length); var dis; if(len&gt;arr1.length)&#123; dis = len - arr1.length; while(dis--)&#123; arr1.unshift(0); &#125; &#125;else&#123; dis = len - arr2.length; while(dis--)&#123; arr2.unshift(0); &#125; &#125; var count = 0; for(var i=0;i&lt;arr1.length;i++)&#123; if(arr1[i]!=arr2[i])&#123; count++; &#125; &#125; return count;&#125;; 123456789101112//空间复杂度低的方法var hammingDistance = function(x, y) &#123; x = x^y;//x与y的异或 var count = 0; while(x!=0)&#123; if(x%2==1)&#123; count++; &#125; x&gt;&gt;=1; &#125; return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-494-538","slug":"leetcode-494-538","date":"2019-10-21T03:49:17.000Z","updated":"2019-10-21T04:03:35.301Z","comments":true,"path":"2019/10/21/leetcode-494-538/","link":"","permalink":"https://www.cuicui88.com/2019/10/21/leetcode-494-538/","excerpt":"leetcode 494 538题","text":"leetcode 494 538题 leetcode 494题题目：给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 解答：123456789101112131415161718192021var findTargetSumWays = function(nums, S) &#123; var sum = 0; for(var i=0;i&lt;nums.length;i++)&#123; sum = sum + nums[i]; &#125; if(sum&lt;S||(sum+S)%2!=0)&#123; return 0; &#125; var arr = []; var w = parseInt((sum+S)/2); for(var j=0;j&lt;w+1;j++)&#123; arr[j] = 0; &#125; arr[0] = 1; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=w;j&gt;=nums[i];j--)&#123; arr[j] = arr[j] + arr[j-nums[i]]; &#125; &#125; return arr[w];&#125;; leetcode538题题目：给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 解答：1234567891011121314var convertBST = function(root) &#123; var num = 0; function convert1(root)&#123; if(root==null)&#123; return; &#125; convert1(root.right); root.val = root.val + num; num = root.val; convert1(root.left); &#125; convert1(root); return root;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-543-560","slug":"leetcode-543-560","date":"2019-10-18T07:33:22.000Z","updated":"2019-10-18T07:45:27.532Z","comments":true,"path":"2019/10/18/leetcode-543-560/","link":"","permalink":"https://www.cuicui88.com/2019/10/18/leetcode-543-560/","excerpt":"leetcode 543 560题","text":"leetcode 543 560题 leetcode543题题目：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 解答：123456789101112131415var diameterOfBinaryTree = function(root) &#123; var result = 0; deep(root); return result; function deep(root)&#123; if(!root)&#123; return -1; &#125; var left = root.left?deep(root.left)+1:0; var right = root.right?deep(root.right)+1:0; result = Math.max(left+right,result); return Math.max(left,right); &#125;&#125;; leetcode 560题题目：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例：&nbsp;&nbsp;&nbsp;&nbsp;输入：nums = [1,1,1],k=2 &nbsp;&nbsp;&nbsp;&nbsp;输出：2, [1,1]与[1,1]为两种不同的情况。 解答：12345678910111213var subarraySum = function(nums, k) &#123; var count = 0; for(var i=0;i&lt;nums.length;i++)&#123; var sum = 0; for(var j=i;j&lt;nums.length;j++)&#123; sum += nums[j]; if(sum==k)&#123; count++; &#125; &#125; &#125; return count;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-572-581","slug":"leetcode-572-581","date":"2019-10-16T13:38:51.000Z","updated":"2019-10-16T14:09:44.320Z","comments":true,"path":"2019/10/16/leetcode-572-581/","link":"","permalink":"https://www.cuicui88.com/2019/10/16/leetcode-572-581/","excerpt":"leetcode 572 581题","text":"leetcode 572 581题 leetcode572题题目：给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 解答： 先定义一个函数isCommon，这个函数用来判断两个树是否是相等的。 然后在isSubtree这个函数中，首先判断s是否为null，如果为null，返回false；如果s和t经isCommon这个函数判断是相同的，那么返回true；否则去判断，s.left里面是否包含树t或者s.right里面是否包含树t。 123456789101112131415161718192021var isSubtree = function(s, t) &#123; if(!s)&#123; return false; &#125; if(isCommon(s,t))&#123; return true; &#125; return isSubtree(s.left,t)||isSubtree(s.right,t);&#125;;function isCommon(s,t)&#123; if(!s&amp;&amp;!t)&#123; return true; &#125; if(!s||!t)&#123; return false; &#125; if(s.val!==t.val)&#123; return false; &#125; return isCommon(s.left,t.left)&amp;&amp;isCommon(s.right,t.right);&#125; leetcode581题题目：给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例：&nbsp;&nbsp;&nbsp;&nbsp;输入: [2, 6, 4, 8, 10, 9, 15]&nbsp;&nbsp;&nbsp;&nbsp;输出: 5&nbsp;&nbsp;&nbsp;&nbsp;解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 解答：分为两个步骤： 遍历整个数组元素，确定最终的high值。如果是数组的第一个元素，那么将maxValue值确定为该值，如果不是，将nums[i]值与maxValue值进行比较，如果小于maxValue，代表这个值是乱序中的一个，故此时的high值为这个元素对应的i；无论是否小于maxValue，我们都需要重新确定maxValue值，这个值为现在的maxValue值与nums[i]两者最大值。 同上面，遍历整个数组元素，确定最终的low值。如果是数组的最后一个元素，将minValue确定为该值，如果不是，将nums[i]与minValue值进行比较，如果大于minValue，代表这个值是乱序中的一个，故此时的low值为这个元素对应的i；无论是否大于minValue，我们都需要重新确定maxValue值，这个值为现在的minValue值与nums[i]两者的最小值。 确定了low和high，就可以通过两者的差值再加1得到最终的乱序序列长度。 123456789101112131415161718192021222324252627282930var findUnsortedSubarray = function(nums) &#123; if(nums.length==0||nums.length==1)&#123; return 0; &#125; var maxValue; var minValue; var high = 0; var low = 1; for(var i=0;i&lt;nums.length;i++)&#123; if(i==0)&#123; maxValue = nums[i]; &#125;else&#123; if(nums[i]&lt;maxValue)&#123; high = i; &#125; maxValue = Math.max(nums[i],maxValue); &#125; &#125; for(var i=nums.length-1;i&gt;=0;i--)&#123; if(i==nums.length-1)&#123; minValue = nums[i]; &#125;else&#123; if(nums[i]&gt;minValue)&#123; low = i; &#125; minValue = Math.min(nums[i],minValue); &#125; &#125; return high-low+1;&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode-617-621","slug":"leetcode-617-621","date":"2019-10-15T13:51:56.000Z","updated":"2019-10-15T14:08:28.576Z","comments":true,"path":"2019/10/15/leetcode-617-621/","link":"","permalink":"https://www.cuicui88.com/2019/10/15/leetcode-617-621/","excerpt":"leetcode 617题 621题","text":"leetcode 617题 621题 leetcode617题题目给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 解答：123456789101112var mergeTrees = function(t1, t2) &#123; if(t1==null)&#123; return t2; &#125; if(t2==null)&#123; return t1; &#125; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); return t1;&#125;; leetcode621题题目：给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例:&nbsp;&nbsp;&nbsp;&nbsp;输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2&nbsp;&nbsp;&nbsp;&nbsp;输出: 8&nbsp;&nbsp;&nbsp;&nbsp;执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 解答：123456789101112131415161718192021222324var leastInterval = function(tasks, n) &#123; var obj = &#123;&#125;; for(var i=0;i&lt;tasks.length;i++)&#123; if(obj[tasks[i]]!=undefined)&#123; obj[tasks[i]]++; &#125;else&#123; obj[tasks[i]]=1; &#125; &#125; var maxValue = 0; var count=0; for(var key in obj)&#123; if(maxValue&lt;obj[key])&#123; maxValue = obj[key]; &#125; &#125; for(var key in obj)&#123; if(maxValue==obj[key])&#123; count++; &#125; &#125; return Math.max.call(null,tasks.length,(maxValue-1)*(n+1)+count);&#125;;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"leetcode 647 771","slug":"leetcode-647-771","date":"2019-10-14T13:26:01.000Z","updated":"2019-10-15T14:12:43.227Z","comments":true,"path":"2019/10/14/leetcode-647-771/","link":"","permalink":"https://www.cuicui88.com/2019/10/14/leetcode-647-771/","excerpt":"leetcode 647题 771题","text":"leetcode 647题 771题 leetcode 647题 题目：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例1： &emsp;&emsp;输入: “abc” &emsp;&emsp;输出: 3 &emsp;&emsp;解释: 三个回文子串: “a”, “b”, “c”. 示例2： &emsp;&emsp;输入: “aaa” &emsp;&emsp;输出: 6 &emsp;&emsp;说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 解答1（复杂度高的版本）：1234567891011121314151617181920212223242526var countSubstrings = function(s) &#123; var count = s.length; for(var len=2;len&lt;=s.length;len++)&#123; for(var i=0;i&lt;=s.length-len;i++)&#123; var subStr = s.substr(i,len); if(judge(subStr))&#123; count++; &#125; &#125; &#125; return count;&#125;;//首先判断一个字符串是否为回文子串function judge(s)&#123; var s = s.split(&apos;&apos;); if(s.length==1)&#123; return true; &#125; for(var i=0;i&lt;parseInt(s.length/2);i++)&#123; if(s[i]!=s[s.length-1-i])&#123; return false; &#125; &#125; return true;&#125; 解答2（复杂度低的版本）：1234567891011121314151617var countSubstrings = function(s) &#123; var count = 0; for(var i=0;i&lt;=s.length;i++)&#123; count += countSinglePoint(s,i,i);//计算子串长度为奇数对应的回文子串个数 count += countSinglePoint(s,i,i+1);//计算子串长度为偶数对应的回文子串个数 &#125; return count;&#125;;function countSinglePoint(s,i,j)&#123; var num = 0; while(i&gt;=0&amp;&amp;j&lt;s.length&amp;&amp;s[i]==s[j])&#123; i--; j++; num++; &#125; return num;&#125; leetcode771题题目：给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例1： &emsp;&emsp;输入: J = “aA”, S = “aAAbbbb” &emsp;&emsp;输出: 3 示例2： &emsp;&emsp;输入：J = “z”, S = “ZZ” &emsp;&emsp;输出：0 解答1：1234567891011121314var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); var count = 0; for(var i=0;i&lt;str2.length;i++)&#123; for(var j=0;j&lt;str1.length;j++)&#123; if(str2[i]==str1[j])&#123; count++; break; &#125; &#125; &#125; return count;&#125;; 解答2：123456789101112131415var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); var obj = &#123;&#125;; var count = 0; for(var i=0;i&lt;str1.length;i++)&#123; obj[str1[i]] = 1; &#125; for(var j=0;j&lt;str2.length;j++)&#123; if(obj[str2[j]]==1)&#123; count++; &#125; &#125; return count;&#125; 解答3：12345var numJewelsInStones = function(J, S) &#123; var str1 = J.split(&apos;&apos;); var str2 = S.split(&apos;&apos;); return str2.filter(item=&gt;str1.includes(item)).length;&#125;","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.cuicui88.com/tags/leetcode/"}]},{"title":"实习面试-微众银行","slug":"micro-public-bank-interview","date":"2019-04-17T09:17:16.000Z","updated":"2019-04-17T09:32:09.365Z","comments":true,"path":"2019/04/17/micro-public-bank-interview/","link":"","permalink":"https://www.cuicui88.com/2019/04/17/micro-public-bank-interview/","excerpt":"微众银行面试凉经","text":"微众银行面试凉经 微众银行面试凉凉： 面试官首先说我的简历太过于简陋（我记得自己是上传了的，感觉很神奇。事后我打开官网看了一下，啥都没有，我也是很迷茫。。） 然后问我有没有做过什么项目，接触过前端的框架没有，我说接触过react，然后用react去模仿了简书的网页。面试官问我项目有没有上线呀什么的，我说没有，只是拿来练手的。然后面试官问我项目中有没有涉及到关于逻辑业务的部分，比如登录注册页面的实现什么的，我说没（还说了通过访问json从后台获取数据这算不算）。估计对项目这里确实是绝望透顶了吧，所以说下面开始问基础知识。————-目测这里就凉了一大截了！！！ 问我平时看什么书，我说我看的是红宝书-javascript高级程序设计，然后就让我解释一下原型链，我解释了一下。然后面试官说我基础还不错。 中途因为我的电脑网速太慢，切到了手机上面试（面试官说他本来要让编程的，编程的话，主要好像是要做链表和字符串的编程，现在想想，我还是手写代码写的太少了，然后算法的准备也不充足–》面试之前只准备了快速排序，冒泡排序还有深度遍历和广度遍历）。然后问了我赛马问题，我当时一脸懵，对于完全没有看过这个题的我感觉很难，然后一切就这样结束了。 又是不到20分钟的一场面试，综合来看，这段时间基础复习得还算可以了。但是项目方面，真的是一言难尽。前后端的这些交互啊什么的，是必须要的（突然想起来师兄说：他到公司就会做项目。现在才意识到自己这方面的不足）。然后就是算法题方面，虽然因为电脑网速的原因没有敲代码（虽然我感觉就算我敲也敲不出来哈哈哈），但是肯定欠缺很大。智力题的话，我实在是没辙啊！！ 综上，现在要准备的是算法题和项目，算法题的话，每天两道前端的算法题，滚瓜烂熟。然后项目的话，要去实现一些复杂的功能，不然面试官会很无语的，面啥挂啥！！","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.cuicui88.com/tags/面试/"}]},{"title":"mood-2019-3-27","slug":"mood-2019-3-27","date":"2019-03-27T04:05:07.000Z","updated":"2019-03-27T05:58:10.764Z","comments":true,"path":"2019/03/27/mood-2019-3-27/","link":"","permalink":"https://www.cuicui88.com/2019/03/27/mood-2019-3-27/","excerpt":"今天任务完成的不太好","text":"今天任务完成的不太好 &emsp;今天老师叫我们去提交任务完成情况的时候，我匆匆忙忙，并没有将老师需要我们提交的内容整理出来。因为几乎忘记了老师之前要求我做的事情。包括写方案分析和报告以及关于搜索唤醒词识别的相关内容（我做的事情是继续老师上一次布置的任务）。 &emsp;事实证明，先弄完老师东西，再去做自己的事情，才是比较正确的，不然会心力交瘁！","categories":[{"name":"life","slug":"life","permalink":"https://www.cuicui88.com/categories/life/"}],"tags":[{"name":"mood","slug":"mood","permalink":"https://www.cuicui88.com/tags/mood/"}]},{"title":"学习打卡-2019.3.25","slug":"2019-3-25-complete","date":"2019-03-25T14:52:31.000Z","updated":"2019-03-25T15:18:59.228Z","comments":true,"path":"2019/03/25/2019-3-25-complete/","link":"","permalink":"https://www.cuicui88.com/2019/03/25/2019-3-25-complete/","excerpt":"爱学习，爱探索","text":"爱学习，爱探索 完成了在博客中添加音乐的功能。 解决了谷歌浏览器无法通过fiddler进行重定向获取本地数据的问题！！！开心到飞起~~","categories":[{"name":"learn","slug":"learn","permalink":"https://www.cuicui88.com/categories/learn/"}],"tags":[{"name":"fiddler 音乐","slug":"fiddler-音乐","permalink":"https://www.cuicui88.com/tags/fiddler-音乐/"}]},{"title":"观比悲伤更悲伤的故事","slug":"lifeMoive","date":"2019-03-25T03:51:30.000Z","updated":"2019-03-25T09:09:23.364Z","comments":true,"path":"2019/03/25/lifeMoive/","link":"","permalink":"https://www.cuicui88.com/2019/03/25/lifeMoive/","excerpt":"爱生活，爱电影","text":"爱生活，爱电影 &emsp;以前看过韩版的比悲伤更悲伤的故事，只记得当时被故事感动地一塌糊涂，其余电影中的各种情节都不太记得了。 &emsp;这次怀着好奇的心情去看了台湾拍的这部与韩国同名的爱情电影，电影中男主为女主所做的一切切实让人感动。男主得知自己的病情之后，即便与女主同住一个屋檐下十几年，也没有跟女主确立男女朋友关系。并且为女主以后生活的幸福付出了太多太多。而女主也一直知道男主的病情与付出，但是她并没有向男主坦白，直到男主快要去世的时候，她才丢下了男主为她安排的一切，去照顾男主。并选择在男主去世的之后选择了追随男主而去。最终与男主永远幸福快乐地生活在了一起。 &emsp;最后，强烈推荐这部剧中的由天生歌姬A-Lin演唱的歌曲《有一种悲伤》。","categories":[{"name":"life","slug":"life","permalink":"https://www.cuicui88.com/categories/life/"}],"tags":[{"name":"moive","slug":"moive","permalink":"https://www.cuicui88.com/tags/moive/"}]}]}